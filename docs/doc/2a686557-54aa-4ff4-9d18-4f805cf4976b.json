{
    "summary": "This code initializes mutable arrays and dictionaries, updates SP strength values, uses AIFoundation library, handles bug 29094, defines AI foundation, updates cansets, adds new ones, and ensures NSCoding compliance.",
    "details": [
        {
            "comment": "This code defines methods for accessing and initializing mutable arrays and dictionaries within the AIFoNodeBase class. The ISOK function checks if the variable is nil and allocates a new instance of the specified class if it is.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":0-33",
            "content": "//\n//  AIFoNodeBase.m\n//  SMG_NothingIsAll\n//\n//  Created by jiaxiaogang on 2018/10/19.\n//  Copyright \u00a9 2018\u5e74 XiaoGang. All rights reserved.\n//\n#import \"AIFoNodeBase.h\"\n@implementation AIFoNodeBase\n-(NSMutableArray *)deltaTimes{\n    if (!_deltaTimes) _deltaTimes = [[NSMutableArray alloc] init];\n    return _deltaTimes;\n}\n-(NSMutableDictionary *)spDic{\n    if (!ISOK(_spDic, NSMutableDictionary.class)) _spDic = [[NSMutableDictionary alloc] initWithDictionary:_spDic];\n    return _spDic;\n}\n-(NSMutableDictionary *)effectDic{\n    if (!ISOK(_effectDic, NSMutableDictionary.class)) _effectDic = [[NSMutableDictionary alloc] initWithDictionary:_effectDic];\n    return _effectDic;\n}\n-(NSMutableDictionary *)absIndexDDic{\n    if (!ISOK(_absIndexDDic, NSMutableDictionary.class)) _absIndexDDic = [[NSMutableDictionary alloc] initWithDictionary:_absIndexDDic];\n    return _absIndexDDic;\n}\n-(NSMutableDictionary *)conIndexDDic{\n    if (!ISOK(_conIndexDDic, NSMutableDictionary.class)) _conIndexDDic = [[NSMutableDictionary alloc] initWithDictionary:_conIndexDDic];"
        },
        {
            "comment": "This code contains methods that return mutable dictionaries and arrays, and a comment for an incomplete method. The comment refers to updating SP strength values based on a given index, which can represent responsibility frames or MV content count. The code also includes sections marked as \"spDic\u7ec4\" which may contain related functions or variables.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":34-60",
            "content": "    return _conIndexDDic;\n}\n-(NSMutableDictionary *)conCansetsDic {\n    if (!ISOK(_conCansetsDic, NSMutableDictionary.class)) _conCansetsDic = [[NSMutableDictionary alloc] initWithDictionary:_conCansetsDic];\n    return _conCansetsDic;\n}\n-(NSMutableArray *)transferAbsPorts{\n    if (!ISOK(_transferAbsPorts, NSMutableArray.class)) _transferAbsPorts = [[NSMutableArray alloc] initWithArray:_transferAbsPorts];\n    return _transferAbsPorts;\n}\n-(NSMutableArray *)transferConPorts{\n    if (!ISOK(_transferConPorts, NSMutableArray.class)) _transferConPorts = [[NSMutableArray alloc] initWithArray:_transferConPorts];\n    return _transferConPorts;\n}\n//MARK:===============================================================\n//MARK:                     < spDic\u7ec4 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u66f4\u65b0SP\u5f3a\u5ea6\u503c--------------------\n *  @param spIndex : \u5f53\u524d\u8981\u66f4\u65b0sp\u5f3a\u5ea6\u503c\u7684\u4e0b\u6807 (\u53c2\u800325031-3);\n *                    1. \u8868\u793a\u8d23\u4efb\u5e27\u4e0b\u6807,\u6bd4\u5982\u4e3a1\u65f6,\u5219\u8868\u793a\u7b2c2\u5e27\u7684\u8d23\u4efb;\n *                    2. \u5982\u679c\u662fmv\u5219\u8f93\u5165content.count;"
        },
        {
            "comment": "This code defines methods to update the strength of SP (Strong Points) in a data structure called spDic. The updateSPStrong method takes an index and updates the strong value linearly or parameter-wise based on the type parameter. There is also a convenience method updateSPStrong:end:type: that iterates over a range of indices to update their strength values. Finally, there is a method updateSPDic: that replaces the entire spDic dictionary with a new one.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":61-97",
            "content": " */\n-(void) updateSPStrong:(NSInteger)spIndex type:(AnalogyType)type {\n    [self updateSPStrong:spIndex difStrong:1 type:type];\n}\n-(void) updateSPStrong:(NSInteger)spIndex difStrong:(NSInteger)difStrong type:(AnalogyType)type {\n    //1. \u53d6kv;\n    NSNumber *key = @(spIndex);\n    AISPStrong *value = [self.spDic objectForKey:key];\n    if (!value) value = [[AISPStrong alloc] init];\n    //2. \u66f4\u65b0\u5f3a\u5ea6_\u7ebf\u6027+1 (\u53c2\u800325031-7);\n    if (type == ATSub) {\n        value.sStrong += difStrong;\n    }else if(type == ATPlus){\n        value.pStrong += difStrong;\n    }\n    [self.spDic setObject:value forKey:key];\n    //3. \u4fdd\u5b58fo\n    [SMGUtils insertNode:self];\n}\n/**\n *  MARK:--------------------\u4ecestart\u5230end\u90fd\u8ba1\u4e00\u6b21P--------------------\n *  @desc \u542bstart \u4e5f\u542bend;\n */\n-(void) updateSPStrong:(NSInteger)start end:(NSInteger)end type:(AnalogyType)type{\n    for (NSInteger i = start; i <= end; i++) {\n        [self updateSPStrong:i type:type];\n    }\n}\n/**\n *  MARK:--------------------\u66f4\u65b0\u6574\u4e2aspDic--------------------\n */\n-(void) updateSPDic:(NSDictionary*)newSPDic {\n    newSPDic = DICTOOK(newSPDic);"
        },
        {
            "comment": "This code is iterating over a new dictionary and updating the strong models in the SP dictionary. It also includes comments on an outdated method for updating effect strengths that has been deprecated.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":98-122",
            "content": "    for (NSNumber *newIndex in newSPDic) {\n        AISPStrong *newStrong = [newSPDic objectForKey:newIndex];\n        [self updateSPStrong:newIndex.integerValue difStrong:newStrong.sStrong type:ATSub];\n        [self updateSPStrong:newIndex.integerValue difStrong:newStrong.pStrong type:ATPlus];\n    }\n}\n//MARK:===============================================================\n//MARK:                     < effectDic\u7ec4 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u66f4\u65b0\u6709\u6548\u7387\u503c--------------------\n *  @version\n *      2022.05.27; \u5e9f\u5f03,eff\u6539\u6210\u53cd\u7701\u7684\u4e00\u79cd\u4e86,\u6240\u4ee5\u4e0d\u518d\u9700\u8981effDic\u4e86 (\u53c2\u800326127-TODO1);\n *  @result \u5c06\u66f4\u65b0\u540e\u7684strong\u6a21\u578b\u8fd4\u56de;\n */\n-(AIEffectStrong*) updateEffectStrong:(NSInteger)effectIndex solutionFo:(AIKVPointer*)solutionFo status:(EffectStatus)status{\n    //1. \u53d6kv (\u65e0\u5219\u65b0\u5efa);\n    NSNumber *key = @(effectIndex);\n    NSMutableArray *value = [[NSMutableArray alloc] initWithArray:[self.effectDic objectForKey:key]];\n    [self.effectDic setObject:value forKey:key];\n    //2. \u53d6\u65e7\u6709strong (\u65e0\u5219\u65b0\u5efa);\n "
        },
        {
            "comment": "This method retrieves a strong effect for the given solution Fo. It checks if an existing strong effect matches the provided solution Fo, and increments the strong count accordingly. It also inserts the current node into the SMGUtils array before returning the strong effect. This method is called to get the effStrong for a specific task index with the corresponding solution Fo.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":122-152",
            "content": "   AIEffectStrong *strong = [SMGUtils filterSingleFromArr:value checkValid:^BOOL(AIEffectStrong *item) {\n        return [item.solutionFo isEqual:solutionFo];\n    }];\n    if (!strong) {\n        strong = [AIEffectStrong newWithSolutionFo:solutionFo];\n        [value addObject:strong];\n    }\n    //3. \u66f4\u65b0\u5f3a\u5ea6_\u7ebf\u6027+1 (\u53c2\u800325031-7);\n    if (status == ES_NoEff) {\n        strong.nStrong++;\n    }else if(status == ES_HavEff){\n        strong.hStrong++;\n    }\n    //3. \u4fdd\u5b58fo\n    [SMGUtils insertNode:self];\n    return strong;\n}\n/**\n *  MARK:--------------------\u83b7\u53d6canset\u7684effStrong--------------------\n *  @param effectIndex : \u5f53R\u4efb\u52a1\u65f6\u4f20self.count,\u5f53H\u4efb\u52a1\u65f6\u5c06\u76f8\u5e94targetIndex\u4f20\u8fc7\u6765;\n */\n-(AIEffectStrong*) getEffectStrong:(NSInteger)effectIndex solutionFo:(AIKVPointer*)solutionFo {\n    //1. \u53d6\u6709\u6548\u7387\u89e3\u51b3\u65b9\u6848\u6570\u7ec4;\n    NSArray *strongs = [ARRTOOK([self.effectDic objectForKey:@(effectIndex)]) copy];\n    //2. \u53d6\u5f97\u5339\u914d\u7684strong;\n    AIEffectStrong *strong = [SMGUtils filterSingleFromArr:strongs checkValid:^BOOL(AIEffectStrong *item) {\n        return [item.solutionFo isEqual:solutionFo];"
        },
        {
            "comment": "This code snippet is from the AIFoundation library and contains methods for getting valid effects, abstract index dictionary, and concrete index dictionary. The getValidEffs method filters out effects with a weaker hStrong value than a minimum threshold. The getAbsIndexDic and getConIndexDic methods retrieve abstract and concrete index dictionaries from data dictionaries using a given pointer ID.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":153-188",
            "content": "    }];\n    //3. \u8fd4\u56de\u6709\u6548\u7387;\n    return strong;\n}\n/**\n *  MARK:--------------------\u53d6effIndex\u4e0b\u6709\u6548\u7684Effs--------------------\n *  @result \u8fd4\u56de\u6709\u6548\u7ed3\u679c: \u6392\u9664\u6709\u6548\u7387\u4e3a0\u7684 (\u53c2\u800326192);\n */\n-(NSArray*) getValidEffs:(NSInteger)effIndex{\n    int minHStrong = 0;//\u6700\u5c0fh\u5f3a\u5ea6\u8981\u6c42 (\u66fe\u75285: \u53c2\u800326199-TODO2);\n    NSArray *effs = [self.effectDic objectForKey:@(effIndex)];\n    return [SMGUtils filterArr:effs checkValid:^BOOL(AIEffectStrong *item) {\n        return item.hStrong > minHStrong;\n    }];\n}\n//MARK:===============================================================\n//MARK:                     < indexDic\u7ec4 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u8fd4\u56deself\u7684\u62bd/\u5177\u8c61\u7684indexDic--------------------\n *  @result indexDic<K:absIndex,V:conIndex>;\n */\n-(NSDictionary*) getAbsIndexDic:(AIKVPointer*)abs_p {\n    return DICTOOK([self.absIndexDDic objectForKey:@(abs_p.pointerId)]);\n}\n-(NSDictionary*) getConIndexDic:(AIKVPointer*)con_p {\n    return DICTOOK([self.conIndexDDic objectForKey:@(con_p.pointerId)]);\n}\n/**\n *  MARK:--------------------\u66f4\u65b0\u62bd\u5177\u8c61indexDic\u5b58\u50a8--------------------"
        },
        {
            "comment": "This code updates the abstract and concrete index dictionaries for a node and its corresponding abstract node. It also inserts both nodes into a set of nodes for future reference. Additionally, it retrieves all candidate sets greater than or equal to a specific target index and potentially includes them if the task is an H task.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":189-216",
            "content": " *  @param absFo : \u4f20\u62bd\u8c61\u8282\u70b9\u8fdb\u6765,\u800cself\u4e3a\u5177\u8c61\u8282\u70b9;\n *  @version\n *      2022.11.15: \u5c06\u62bd\u5177\u8c61\u5173\u7cfb\u4e5f\u5b58\u4e0a\u5339\u914d\u6620\u5c04 (\u53c2\u800327177-todo5);\n */\n-(void) updateIndexDic:(AIFoNodeBase*)absFo indexDic:(NSDictionary*)indexDic {\n    //1. \u66f4\u65b0\u62bd\u5177\u8c61\u4e24\u4e2aindexDDic;\n    [self.absIndexDDic setObject:indexDic forKey:@(absFo.pointer.pointerId)];\n    [absFo.conIndexDDic setObject:indexDic forKey:@(self.pointer.pointerId)];\n    //2. \u4fdd\u5b58\u8282\u70b9;\n    [SMGUtils insertNode:self];\n    [SMGUtils insertNode:absFo];\n}\n//MARK:===============================================================\n//MARK:                     < conCansets\u7ec4 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u83b7\u53d6\u6240\u6709\u5019\u9009\u96c6--------------------\n *  @desc \u5c06>=targetIndex\u4e0b\u6807\u5bf9\u5e94\u7684\u89e3\u51b3\u65b9\u6848\u5019\u9009\u96c6\u6253\u5305\u8fd4\u56de (\u53c2\u800327204b);\n *  @version\n *      2023.09.10: H\u4efb\u52a1\u65f6,>targetIndex\u7684\u672a\u5fc5\u5305\u542btargetIndex,\u6240\u4ee5\u52a0\u4e0aH\u4efb\u52a1\u65f6,canset\u4e2d\u5fc5\u987b\u5305\u542btargetIndex\u5bf9\u5e94\u5e27;\n *  @result notnull\n */\n-(NSArray*) getConCansets:(NSInteger)targetIndex {\n    NSMutableArray *result = [[NSMutableArray alloc] init];\n    BOOL forH = targetIndex < self.count;"
        },
        {
            "comment": "Updates a candidate in the given `newConCansetFo` by filtering and adding it to the result array. If the target index exists, returns true; otherwise, false. If the new canset has only one or less elements, the method returns false as there is no behavior to be extracted (referenced issue numbers: 28052-4, 29094-BUG1).",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":217-241",
            "content": "    for (NSInteger i = targetIndex; i <= self.count; i++) {\n        NSArray *itemArr = ARRTOOK([self.conCansetsDic objectForKey:@(i)]);\n        if (forH) { //H\u4efb\u52a1\u65f6,\u8981\u6c42canset\u4e2d\u5fc5\u987b\u5305\u542btargetIndex\u6620\u5c04\u5e27;\n            itemArr = [SMGUtils filterArr:itemArr checkValid:^BOOL(AIKVPointer *item) {\n                NSDictionary *indexDic = [self getConIndexDic:item];\n                return [indexDic objectForKey:@(targetIndex)];\n            }];\n        }\n        [result addObjectsFromArray:itemArr];\n    }\n    return [SMGUtils removeRepeat:result];\n}\n/**\n *  MARK:--------------------\u66f4\u65b0\u4e00\u6761\u5019\u9009--------------------\n *  @version\n *      2023.06.16: \u4fee\u590d\u66f4\u65b0updateEffectStrong\u7684targetIndex\u4f20\u9519\u4e86,\u6bcf\u6b21\u90fd\u4f20\u76841\u7684\u95ee\u9898 (\u53c2\u800330023-\u4fee\u590d);\n *  @result \u5c06\u662f\u5426\u4fdd\u5b58\u6210\u529f\u8fd4\u56de (\u957f\u5ea6\u4e3a1\u53ca\u4ee5\u4e0b\u7684\u6ca1\u540e\u6bb5,\u6240\u4ee5\u76f4\u63a5\u4e0d\u5b58\u4e86) (\u53c2\u800328052-4 && 29094-BUG1);\n */\n-(BOOL) updateConCanset:(AIKVPointer*)newConCansetFo targetIndex:(NSInteger)targetIndex {\n    //0. canset\u6ca1\u540e\u6bb5\u7684\u76f4\u63a5\u4e0d\u5b58\u4e86 (\u6ca1\u53ef\u884c\u4e3a\u5316\u7684\u4e1c\u897f) (\u53c2\u800328052-4);\n    AIFoNodeBase *newCanset = [SMGUtils searchNode:newConCansetFo];\n    if (newCanset.count <= 1) return false;\n    //1. \u66f4\u65b0\u4e00\u6761\u5019\u9009;"
        },
        {
            "comment": "This code appears to be part of an AI foundation, specifically within the context of a node base. It retrieves transfer-related cansets from scenes and updates their effect strength. If the new canset is not already included in the array of cansets for the target index, it adds it and updates the dictionary. Finally, it calls a method to insert the node and returns true.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":242-267",
            "content": "    NSMutableArray *conCansets = [[NSMutableArray alloc] initWithArray:[self.conCansetsDic objectForKey:@(targetIndex)]];\n    if (![conCansets containsObject:newConCansetFo]) {\n        [conCansets addObject:newConCansetFo];\n        [self.conCansetsDic setObject:conCansets forKey:@(targetIndex)];\n        [SMGUtils insertNode:self];\n    }\n    //2. \u66f4\u65b0\u540e (\u65b0\u7684\u9ed8\u8ba4eff.h=1,\u65e7\u7684eff\u5219\u589e\u5f3a+1);\n    [self updateEffectStrong:targetIndex solutionFo:newConCansetFo status:ES_HavEff];\n    return true;\n}\n//MARK:===============================================================\n//MARK:                     < transfer\u7ec4 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u627e\u51fa\u4ea4\u5c42\u573a\u666f\u4e2d,\u6709\u54ea\u4e9bcanset\u662f\u4e0e\u5f53\u524dfo\u8fc1\u79fb\u5173\u8054\u7684--------------------\n */\n-(NSArray*) getTransferAbsCansets:(AIKVPointer*)absScene_p {\n    return [self filterCansetsWithScene:absScene_p fromTransferPorts:self.transferAbsPorts];\n}\n/**\n *  MARK:--------------------\u627e\u51fa\u4f3c\u5c42\u573a\u666f\u4e2d,\u6709\u54ea\u4e9bcanset\u662f\u4e0e\u5f53\u524dfo\u8fc1\u79fb\u5173\u8054\u7684--------------------\n */\n-(NSArray*) getTransferConCansets:(AIKVPointer*)conScene_p {"
        },
        {
            "comment": "This code is defining a private method that filters transfer ports based on a specific scene and converts the resulting cansets into an array. The filtering process is done using SMGUtils, which checks for port scene equality and performs conversions. The code also includes an initWithCoder method for NSCoding compliance.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":268-293",
            "content": "    return [self filterCansetsWithScene:conScene_p fromTransferPorts:self.transferConPorts];\n}\n//MARK:===============================================================\n//MARK:                     < privateMethod >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u4ecefromTransferPorts\u4e2d\u7b5b\u9009\u51fa: \u573a\u666f\u662fscene\u7684\u5e76\u8f6c\u6210cansets\u683c\u5f0f--------------------\n */\n-(NSArray*) filterCansetsWithScene:(AIKVPointer*)scene fromTransferPorts:(NSArray*)fromTransferPorts {\n    return [SMGUtils convertArr:[SMGUtils filterArr:fromTransferPorts checkValid:^BOOL(AITransferPort *port) {\n        return [port.scene isEqual:scene];\n    }] convertBlock:^id(AITransferPort *port) {\n        return port.canset;\n    }];\n}\n/**\n *  MARK:--------------------NSCoding--------------------\n */\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {\n    self = [super initWithCoder:aDecoder];\n    if (self) {\n        self.cmvNode_p = [aDecoder decodeObjectForKey:@\"cmvNode_p\"];\n        self.deltaTimes = [aDecoder decodeObjectForKey:@\"deltaTimes\"];"
        },
        {
            "comment": "This code is decoding and encoding object properties using NSCoder in Objective-C. It saves and restores the state of the object for archiving and unarchiving operations. The properties being encoded include cmvNode_p, deltaTimes, mvDeltaTime, spDic (copy), and effectDic.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":294-312",
            "content": "        self.mvDeltaTime = [aDecoder decodeDoubleForKey:@\"mvDeltaTime\"];\n        self.spDic = [aDecoder decodeObjectForKey:@\"spDic\"];\n        self.effectDic = [aDecoder decodeObjectForKey:@\"effectDic\"];\n        self.absIndexDDic = [aDecoder decodeObjectForKey:@\"absIndexDDic\"];\n        self.conIndexDDic = [aDecoder decodeObjectForKey:@\"conIndexDDic\"];\n        self.conCansetsDic = [aDecoder decodeObjectForKey:@\"conCansetsDic\"];\n        self.transferAbsPorts = [aDecoder decodeObjectForKey:@\"transferAbsPorts\"];\n        self.transferConPorts = [aDecoder decodeObjectForKey:@\"transferConPorts\"];\n    }\n    return self;\n}\n- (void)encodeWithCoder:(NSCoder *)aCoder {\n    [super encodeWithCoder:aCoder];\n    [aCoder encodeObject:self.cmvNode_p forKey:@\"cmvNode_p\"];\n    [aCoder encodeObject:self.deltaTimes forKey:@\"deltaTimes\"];\n    [aCoder encodeDouble:self.mvDeltaTime forKey:@\"mvDeltaTime\"];\n    [aCoder encodeObject:[self.spDic copy] forKey:@\"spDic\"];\n    [aCoder encodeObject:[self.effectDic copy] forKey:@\"effectDic\"];"
        },
        {
            "comment": "Encodes object values of absIndexDDic, conIndexDDic, conCansetsDic, transferAbsPorts, and transferConPorts for key storage.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINode/AIFoNodeBase.m\":313-320",
            "content": "    [aCoder encodeObject:[self.absIndexDDic copy] forKey:@\"absIndexDDic\"];\n    [aCoder encodeObject:[self.conIndexDDic copy] forKey:@\"conIndexDDic\"];\n    [aCoder encodeObject:[self.conCansetsDic copy] forKey:@\"conCansetsDic\"];\n    [aCoder encodeObject:[self.transferAbsPorts copy] forKey:@\"transferAbsPorts\"];\n    [aCoder encodeObject:[self.transferConPorts copy] forKey:@\"transferConPorts\"];\n}\n@end"
        }
    ]
}