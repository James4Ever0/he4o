{
    "summary": "The code handles urgent situations in AI game environments, optimizes using caching, and compares AIKVPointer objects based on ID, direction, and score.",
    "details": [
        {
            "comment": "This code defines a method that evaluates whether a subtask has been completed in time. It takes in a current solution and demand model as parameters, and returns true if the subtask can be executed immediately or false if it needs to wait for silent success before proceeding.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":0-30",
            "content": "//\n//  AIScore.m\n//  SMG_NothingIsAll\n//\n//  Created by jia on 2021/1/5.\n//  Copyright \u00a9 2021\u5e74 XiaoGang. All rights reserved.\n//\n#import \"AIScore.h\"\n@implementation AIScore\n//MARK:===============================================================\n//MARK:                     < \u4e0b\u6807\u4e0d\u6025\u8bc4\u4ef7 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u4e0b\u6807\u4e0d\u6025(\u5f04\u5de7\u6210\u62d9)\u8bc4\u4ef7--------------------\n *  @desc\n *          1. \u8bf4\u660e: R\u5b50\u4efb\u52a1\u6765\u7684\u53ca\u8bc4\u4ef7 (\u540e\u7eed\u8003\u8651\u652f\u6301rootR\u4efb\u52a1) (\u53c2\u800322194 & 22195 & 22198);\n *          2. \u51b3\u7b56\u65f6\u5e8fAB \u5728 \u4efb\u52a1\u672a\u53d1\u751f\u90e8\u5206D \u4e2d\u627emIsC (\u627e\u5230AB\u4e2dindex,index\u53ca\u4e4b\u540e\u9700\u8981\u7b49\u5f85\u9759\u9ed8\u6210\u529f,\u4e4b\u524d\u7684\u53ef\u5b9e\u884c\u884c\u4e3a\u5316) (\u53c2\u800322198);\n *          3. \u5fc5\u8981\u6027: ARSTime\u6765\u7684\u53ca\u8bc4\u4ef7\u662f\u9488\u5bf9\u67d0\u5e27\u7684,\u800c\u51b3\u7b56\u4e2d,\u5916\u754c\u6761\u4ef6\u4f1a\u53d8\u5316,\u6240\u4ee5\u5fc5\u987b\u6bcf\u5e27\u90fd\u5355\u72ec\u8bc4\u4ef7;\n *  @param dsFoModel : \u5f53\u524d\u6b63\u5728\u63a8\u8fdb\u7684\u89e3\u51b3\u65b9\u6848,\u5176\u4e2dactionIndex\u4e3a\u5f53\u524d\u5e27;\n *  @param demand : \u5f53\u524d\u4efb\u52a1;\n *  @result (\u53c2\u800322194\u793a\u56fe & 22198) (\u9ed8\u8ba4\u4e3ature);\n *      true    : \u63d0\u524d\u53ef\u9884\u5907\u90e8\u5206:\u8fd4\u56detrue\u4ee5\u8fdb\u884c_hav\u5b9e\u65f6\u884c\u4e3a\u5316 (\u6bd4\u5982:\u5728\u7a7f\u8d8a\u68ee\u6797\u524d,\u5728\u9047\u5230\u8001\u864e\u524d,\u6211\u4eec\u5148\u5e26\u67aa);\n *      false   : \u6765\u7684\u53ca\u8fd4\u56defalse\u5219ActYes\u7b49\u5f85\u9759\u9ed8\u6210\u529f,\u5e76\u7ee7\u7eed\u63a8\u8fdb\u4e3b\u4efb\u52a1 (\u6bd4\u5982:\u67aa\u5df2\u53d6\u5230,\u73b0\u5728\u5148\u7a7f\u8d8a\u68ee\u6797,\u7b49\u8001\u864e\u51fa\u73b0\u65f6,\u518d\u5413\u8dd1\u5b83);\n *  @version\n *      2022.05.19: \u5e9f\u5f03 (\u53c2\u800326051);\n */\n//+(BOOL) ARS_Time:(TOFoModel*)dsFoModel demand:(ReasonDemandModel*)demand{"
        },
        {
            "comment": "This code is finding the index of a specific dsFo model and demand, and then checks if the demand has occurred before the given index. If so, it returns whether the actionIndex is before or after that index. If not, it simply returns true. The function takes a TOFoModel and ReasonDemandModel as parameters and uses a block to return the indices.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":31-56",
            "content": "//    //1. \u627e\u4e0b\u6807;\n//    __block NSInteger dsIndex = -1;\n//    __block NSInteger demandIndex = -1;\n//    [self score4ARSTime:dsFoModel demand:demand finishBlock:^(NSInteger _dsIndex, NSInteger _demandIndex) {\n//        dsIndex = _dsIndex;\n//        demandIndex = _demandIndex;\n//    }];\n//\n//    //2. \u4e0b\u6807\u6709\u6548\u65f6,\u8fd4\u56deARSTime\u7ed3\u679c (\u53c2\u800322194\u793a\u56fe & 22198);;\n//    if (demandIndex != -1) {\n//        //3a. ds\u4e0b\u6807\u540e\u7684dsFo\u90e8\u5206,\u9700\u8981\u9759\u9ed8\u7b49\u5f85 (\u4f1a\u5bfc\u81f4\u5f04\u5de7\u6210\u62d9,\u8bc4\u4ef7\u4e3a\u5426->ActYes);\n//        //3b. ds\u4e0b\u6807\u524d\u7684dsFo\u90e8\u5206,\u53ef\u76f4\u63a5\u884c\u4e3a\u5316 (\u5f53dsAlg\u5728demand\u9884\u6d4b\u4e2d\u5df2\u53d1\u751f\u65f6,\u8bc4\u4ef7\u4e3a\u662f->\u7acb\u9a6c\u884c\u4e3a\u5316\u4fee\u6b63);\n//        return dsFoModel.actionIndex < dsIndex;\n//    }\n//    return true;\n//}\n/**\n *  MARK:--------------------\u6765\u7684\u53ca\u8bc4\u5206--------------------\n *  @desc \u5bf9dsFo\u7684\u4ece\u524d\u5230\u540e\u6240\u6709\u5143\u7d20,\u5728demand\u7684\u9884\u6d4b\u4e2d\u672a\u53d1\u751f\u7684\u90e8\u5206,\u627e\u4e0b\u6807\u8fd4\u56de (\u53c2\u800322198\u793a\u56fe);\n *  @param finishBlock notnull : \u6839\u636edsFo\u7684\u54ea\u4e2a\u4e0b\u6807,\u53d1\u73b0\u4e86\u5728demand\u9884\u6d4bfo\u4e2d\u7684\u54ea\u4e2a\u4e0b\u6807,\u4f7f\u7528\u8bf4\u660e\u5982\u4e0b;\n */\n//+(void) score4ARSTime:(TOFoModel*)dsFoModel demand:(ReasonDemandModel*)demand finishBlock:(void(^)(NSInteger _dsIndex,NSInteger _demandIndex))finishBlock{\n//    //1. \u6570\u636e\u68c0\u67e5;\n//    if (!dsFoModel || !demand) return;\n//    AIFoNodeBase *dsFo = [SMGUtils searchNode:dsFoModel.content_p];"
        },
        {
            "comment": "This code is iterating over an array of objects, checking if any object's index matches a specific demand's index in another array. If there's a match, the function returns early with the corresponding indices. The purpose appears to be evaluating urgent situations based on time constraints for a task.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":57-81",
            "content": "//\n//    //2. \u627e\u4e0b\u6807 (\u53c2\u8003\u6ce8\u91ca@desc);\n//    for (NSInteger i = 0; i < dsFo.count; i++) {\n//        AIKVPointer *dsAlg_p = ARR_INDEX(dsFo.content_ps, i);\n//        AIFoNodeBase *demandMFo = [SMGUtils searchNode:demand.mModel.matchFo];\n//        NSInteger demandIndex = [TOUtils indexOfConOrAbsItem:dsAlg_p atContent:demandMFo.content_ps layerDiff:2 startIndex:demand.mModel.cutIndex2 + 1 endIndex:NSUIntegerMax];\n//\n//        //3. \u6839\u636edsIndex\u53d1\u73b0demandIndex\u6210\u529f (\u4ec5\u9700\u53d1\u73b0\u4e00\u4e2a\u4e0b\u6807\u5373\u53ef);\n//        if (demandIndex != -1) {\n//            finishBlock(i,demandIndex);  //\u6839\u636ei\u53d1\u73b0\u4e86result\n//            return;\n//        }\n//    }\n//}\n//MARK:===============================================================\n//MARK:                     < \u65f6\u95f4\u4e0d\u6025\u8bc4\u4ef7 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u65f6\u95f4\u4e0d\u6025\u8bc4\u4ef7--------------------\n *  @desc \u65f6\u95f4\u4e0d\u6025\u8bc4\u4ef7: \u7d27\u6025\u60c5\u51b5 = \u89e3\u51b3\u65b9\u6848\u6240\u9700\u65f6\u95f4 > \u7236\u4efb\u52a1\u80fd\u7ed9\u7684\u65f6\u95f4 (\u53c2\u8003:24057-\u65b9\u68483,24171-7);\n *  @param demand : \u5f53\u524d\u4efb\u52a1\n *  @version\n *      2022.01.19: \u4eceaction\u524d\u7f6e\u5230rSolution\u4e2d,\u56e0\u4e3a\u4e09\u6761\u5168\u7d27\u6025,\u5c31\u5b8c\u86cb\u4e86,\u653e\u5230action\u5219\u4e0d\u53d7\u6b64\u9650\u5236 (\u53c2\u800325106);"
        },
        {
            "comment": "This code snippet checks if the time is sufficient for a given solution by evaluating the demand model and comparing it to the solution model. It first checks if there are only 1 or fewer segments in the solution, in which case it immediately returns true. Then, it determines the nearest R task (taking self for R tasks and baseRDemand for H tasks) and calculates the time needed for the given solution. If the calculated time is less than or equal to the time of the nearest R task, it returns false indicating urgency; otherwise, it returns true indicating that there is no hurry and the solution can be acted upon.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":82-104",
            "content": " *      2022.02.22: \u5c06needTime\u53d6\u5230mv\u6539\u4e3a\u4ec5\u53d6\u4e0b\u5e27,\u56e0\u4e3a\u5f88\u591asolution\u53ea\u9700\u8981\u4e00\u5e27\u5c31\u6539\u5230\u6b63\u786e\u7684\u9053\u8def\u4e0a\u4e86 (\u53c2\u800325113-\u65b9\u68482);\n *      2022.05.28: \u5224\u65ad\u76ee\u6807\u5411\u540e\u4e00\u5e27 (\u53c2\u800326132-\u65b9\u68482);\n *      2022.05.31: \u517c\u5bb9\u652f\u6301H\u4efb\u52a1 (\u53c2\u800326161-6);\n *      2022.05.31: \u4e2d\u6bb5\u4e3a0\u6761\u65f6,\u8bc4\u4ef7\u76f4\u63a5\u901a\u8fc7 (\u53c2\u800326161-7);\n *  @result \u8fd4\u56de\u662f\u5426\u65f6\u95f4\u4e0d\u6025 (\u9ed8\u8ba4\u4e3atrue);\n *      true    : \u4e0d\u6025,\u65f6\u95f4\u591f\u7528,\u8fd9\u65b9\u6848\u53ef\u7ee7\u7eedact;\n *      false   : \u7d27\u6025,\u8fd9\u65b9\u6848\u6765\u4e0d\u53ca\u6267\u884c,\u76f4\u63a5ActNo\u6389;\n */\n+(BOOL) FRS_Time:(DemandModel*)demand solutionModel:(AICansetModel*)solutionModel{\n    //1. \u4e2d\u6bb5\u4e3a0\u6761\u65f6,\u76f4\u63a5\u8fd4\u56detrue,\u8bc4\u4ef7\u901a\u8fc7;\n    if (solutionModel.targetIndex - solutionModel.cutIndex <= 1) {\n        return true;\n    }\n    //2. \u6700\u8fd1\u7684R\u4efb\u52a1 (R\u4efb\u52a1\u65f6\u53d6\u81ea\u8eab,H\u4efb\u52a1\u65f6\u53d6\u6700\u8fd1\u7684baseRDemand);\n    ReasonDemandModel *nearRDemand = [SMGUtils filterSingleFromArr:[TOUtils getBaseOutModels_AllDeep:demand] checkValid:^BOOL(id item) {\n        return ISOK(item, ReasonDemandModel.class);\n    }];\n    if (!nearRDemand) return false;\n    //3. \u53d6\u89e3\u51b3\u65b9\u6848\u6240\u9700\u65f6\u95f4;\n    AIFoNodeBase *solutionFo = [SMGUtils searchNode:solutionModel.cansetFo];\n    double needTime = [TOUtils getSumDeltaTime:solutionFo startIndex:solutionModel.cutIndex + 1 endIndex:solutionModel.cutIndex + 2];"
        },
        {
            "comment": "This code searches for a node based on a given pointer and checks if there is enough time to complete the task. It returns true if time is not urgent (greater than or equal to the task's required time). The score4MV function scores an MV node and returns its score, using a ratio input.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":106-129",
            "content": "    //4. \u53d6\u7236\u4efb\u52a1\u80fd\u7ed9\u7684\u65f6\u95f4;\n    AIMatchFoModel *firstPFo = ARR_INDEX(nearRDemand.validPFos, 0);\n    AIFoNodeBase *pFo = [SMGUtils searchNode:firstPFo.matchFo];\n    double giveTime = [TOUtils getSumDeltaTime2Mv:pFo cutIndex:firstPFo.cutIndex];\n    //5. \u5224\u65ad\u662f\u5426\u65f6\u95f4\u4e0d\u6025;\n    BOOL timeIsEnough = needTime <= giveTime;\n    if (Log4Score && timeIsEnough) NSLog(@\"> \u65f6\u95f4\u4e0d\u6025%d = \u65b9\u6848T:%.2f <= \u4efb\u52a1T:%.2f\",timeIsEnough,needTime,giveTime);\n    return timeIsEnough;\n}\n//MARK:===============================================================\n//MARK:                     < MPS\u8bc4\u5206 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------MPS\u8bc4\u5206--------------------\n *  @result \u8d1f\u4ef7\u503c\u8fd4\u56de\u8d1f\u5206,\u6b63\u4ef7\u503c\u8fd4\u56de\u6b63\u5206;\n */\n+(CGFloat) score4MV:(AIKVPointer*)cmvNode_p ratio:(CGFloat)ratio{\n    AICMVNodeBase *cmvNode = [SMGUtils searchNode:cmvNode_p];\n    if (ISOK(cmvNode, AICMVNodeBase.class)) {\n        return [AIScore score4MV:cmvNode.pointer.algsType urgentTo_p:cmvNode.urgentTo_p delta_p:cmvNode.delta_p ratio:ratio];\n    }\n    return 0;"
        },
        {
            "comment": "This code calculates a score based on the given algsType, urgentTo, delta, and ratio. It first checks if there is demand for the given algsType and delta. If there is demand, it returns a negative score proportional to urgentTo and ratio. Otherwise, it returns a positive score proportional to urgentTo and ratio. The code also mentions another function called `score4MV_v2` that calculates a score using an AIMatchFoModel input and returns a positive value for positive match factors and negative values for negative match factors.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":130-157",
            "content": "}\n+(CGFloat) score4MV:(NSString*)algsType urgentTo_p:(AIKVPointer*)urgentTo_p delta_p:(AIKVPointer*)delta_p ratio:(CGFloat)ratio{\n    //1. \u68c0\u67e5absCmvNode\u662f\u5426\u987a\u5fc3\n    NSInteger delta = [NUMTOOK([AINetIndex getData:delta_p]) integerValue];\n    NSInteger urgentTo = [NUMTOOK([AINetIndex getData:urgentTo_p]) integerValue];\n    return [self score4MV:algsType urgentTo:urgentTo delta:delta ratio:ratio];\n}\n+(CGFloat) score4MV:(NSString*)algsType urgentTo:(NSInteger)urgentTo delta:(NSInteger)delta ratio:(CGFloat)ratio{\n    //1. \u68c0\u67e5absCmvNode\u662f\u5426\u987a\u5fc3\n    BOOL havDemand = [ThinkingUtils havDemand:algsType delta:delta];\n    //2. \u6839\u636e\u68c0\u67e5\u5230\u7684\u6570\u636e\u53d6\u5230score;\n    ratio = MIN(1,MAX(ratio,0));\n    if (havDemand) {\n        return  -urgentTo * ratio;\n    }else{\n        return urgentTo * ratio;\n    }\n}\n/**\n *  MARK:--------------------\u5bf9\u9884\u6d4b\u4ef7\u503c\u65f6\u5e8f\u8bc4\u5206V2--------------------\n *  @desc score = spScore * mvScore (\u5373\u5c06\u539f\u5339\u914d\u5ea6,\u6539\u4e3a\u7531spScore\u6765\u66ff\u4ee3);\n *  @result 1. \u8fd4\u56de\u8bc4\u5206\u8d8a\u4f4e\u8bf4\u660e\u8d8a\u4e0d\u597d,\u8d8a\u9ad8\u8d8a\u597d;\n *          2. \u8fd4\u56de\u6b63\u503c\u4e3a\u6b63mv,\u8fd4\u56de\u8d1f\u503c\u4e3a\u8d1fmv;\n */\n+(CGFloat) score4MV_v2:(AIMatchFoModel*)inModel{\n    AIFoNodeBase *mFo = [SMGUtils searchNode:inModel.matchFo];"
        },
        {
            "comment": "This code calculates the score for a match (MV) or demand based on various factors and caches the scores for optimization. The score4MV function takes in an AIMatchFoModel, checks if the cache is defaultScore, recalculates the score using v2 method, stores it in the cache, tests the new score, and returns it. The score4Demand function calculates a score for DemandModel objects based on their type and count of pFos, returning the average MV score if applicable.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":158-186",
            "content": "    BOOL isBadMv = [ThinkingUtils havDemand:mFo.cmvNode_p];\n    CGFloat spScore = [TOUtils getSPScore:mFo startSPIndex:inModel.cutIndex + 1 endSPIndex:mFo.count];\n    CGFloat ratio = isBadMv ? (1 - spScore) : spScore;\n    return [AIScore score4MV:mFo.cmvNode_p ratio:ratio];//\u4ef7\u503c\u8feb\u5207\u5ea6 * \u5339\u914d\u5ea6\n}\n/**\n *  MARK:--------------------\u5bf9\u9884\u6d4b\u4ef7\u503c\u65f6\u5e8f\u8bc4\u5206v2 from cache--------------------\n *  @version\n *      2022.08.19: \u6027\u80fd\u4f18\u5316\u7f13\u5b58\u7248 (\u53c2\u800327065);\n */\n+(CGFloat) score4MV_v2FromCache:(AIMatchFoModel*)inModel {\n    if (inModel.scoreCache == defaultScore) {\n        inModel.scoreCache = [self score4MV_v2:inModel];\n    }\n    [AITest test12:inModel.scoreCache];\n    return inModel.scoreCache;\n}\n/**\n *  MARK:--------------------\u5bf9Demand\u7efc\u5408\u8bc4\u5206--------------------\n *  @param demand : \u4ec5\u652f\u6301PR\u4e24\u79cd\u7c7b\u578b\n *  @version\n *      2022.05.19: demand\u7684\u8bc4\u5206,\u7ee7\u627ffirstPFo\u7684\u8bc4\u5206 (\u53c2\u800326042-TODO4);\n *      2022.05.21: demand\u7684\u8bc4\u5206,\u6539\u4e3a\u7efc\u5408sumPFoScore\u8bc4\u5206 (\u53c2\u800326076);\n *      2022.06.08: demand\u7684\u8bc4\u5206,\u6539\u4e3a\u7efc\u5408sumMvScore / pFos.count (\u53c2\u80032619j-TODO6);\n */\n+(CGFloat) score4Demand:(DemandModel*)demand{\n    if (ISOK(demand, ReasonDemandModel.class) ) {"
        },
        {
            "comment": "This code snippet appears to calculate the average value of a set of potential friendly objects (pFos) and returns it. It also includes a nested function that evaluates whether two MVs have the same identifier, and if so, calculates their scores. The main function handles different types of demands, including ReasonDemandModel and PerceptDemandModel. The code seems to be part of an artificial intelligence framework used for decision-making in a game or simulation environment.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":187-215",
            "content": "        ReasonDemandModel *rDemand = (ReasonDemandModel*)demand;\n        return [self score4PFos:rDemand.validPFos];\n    }else if (ISOK(demand, PerceptDemandModel.class) ) {\n        PerceptDemandModel *pDemand = (PerceptDemandModel*)demand;\n        return [AIScore score4MV:pDemand.algsType urgentTo:pDemand.urgentTo delta:pDemand.delta ratio:1.0f];\n    }\n    return 0;\n}\n/**\n *  MARK:--------------------\u6c42pFos\u7684\u5e73\u5747\u4ef7\u503c\u5206--------------------\n */\n+(CGFloat) score4PFos:(NSArray*)pFos {\n    pFos = ARRTOOK(pFos);\n    CGFloat sumScore = 0;\n    for (AIMatchFoModel *pFo in pFos) {\n        sumScore += [AIScore score4MV_v2FromCache:pFo];\n    }\n    return pFos.count > 0 ? sumScore / pFos.count : 0;\n}\n//MARK:===============================================================\n//MARK:                     < MPS\u8bc4\u4ef7 >\n//MARK:===============================================================\n//\u540c\u533a\u4e14\u540c\u5411\n+(BOOL) sameIdenSameScore:(AIKVPointer*)mv1_p mv2:(AIKVPointer*)mv2_p{\n    if ([self sameIdentifierOfMV1:mv1_p mv2:mv2_p]) {\n        CGFloat mScore = [AIScore score4MV:mv1_p ratio:1.0f];"
        },
        {
            "comment": "This code contains various helper functions used for comparing AIKVPointer objects based on their ID, direction, and score. Each function returns a BOOL value indicating whether the given objects are in the same region (sameIdentifierOfMV1), have different directions but the same score (sameIdenNoSameScore), share both the same region and direction (sameIdenSameDelta), or share the same region but opposite directions (sameIdenDiffDelta).",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":216-243",
            "content": "        CGFloat sScore = [AIScore score4MV:mv2_p ratio:1.0f];\n        return [self sameDire:mScore v2:sScore];\n    }\n    return false;\n}\n//\u540c\u533a\u4e0d\u540c\u5411\n+(BOOL) sameIdenNoSameScore:(AIKVPointer*)mv1_p mv2:(AIKVPointer*)mv2_p{\n    CGFloat ratio = 1.0f;\n    return [self sameIdentifierOfMV1:mv1_p mv2:mv2_p] && ![self sameDire:Mvp2Score(mv1_p, ratio) v2:Mvp2Score(mv2_p, ratio)];\n}\n//\u540c\u533a\u4e14\u540c\u5411\n+(BOOL) sameIdenSameDelta:(AIKVPointer*)mv1_p mv2:(AIKVPointer*)mv2_p{\n    return [self sameIdentifierOfMV1:mv1_p mv2:mv2_p] && [self sameDire:Mvp2Delta(mv1_p) v2:Mvp2Delta(mv2_p)];\n    return false;\n}\n//\u540c\u533a\u4e14\u53cd\u5411\n+(BOOL) sameIdenDiffDelta:(AIKVPointer*)mv1_p mv2:(AIKVPointer*)mv2_p{\n    return [self sameIdentifierOfMV1:mv1_p mv2:mv2_p] && [self diffDire:Mvp2Delta(mv1_p) v2:Mvp2Delta(mv2_p)];\n}\n//MARK:===============================================================\n//MARK:                     < \u5355\u7eaf\u540c\u533a\u540c\u5411\u5224\u65ad >\n//MARK:===============================================================\n//\u540c\u533a\n+(BOOL) sameIdentifierOfMV1:(AIKVPointer*)mv1_p mv2:(AIKVPointer*)mv2_p{"
        },
        {
            "comment": "This code defines three methods, all of which compare two values and return a boolean value based on the comparison. The first method compares whether two objects have the same identifier. The second method checks if both values are positive or both are negative (i.e., the same direction). The third method checks if one value is positive and the other is negative (i.e., opposite directions).",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIScore.m\":244-255",
            "content": "    return mv1_p && mv2_p && [mv1_p.identifier isEqualToString:mv2_p.identifier];\n}\n//\u540c\u5411\n+(BOOL) sameDire:(NSInteger)v1 v2:(NSInteger)v2{\n    return (v1 > 0 && v2 > 0) || (v1 < 0 && v2 < 0);\n}\n//\u53cd\u5411\n+(BOOL) diffDire:(NSInteger)v1 v2:(NSInteger)v2{\n    return (v1 > 0 && v2 < 0) || (v1 < 0 && v2 > 0);\n}\n@end"
        }
    ]
}