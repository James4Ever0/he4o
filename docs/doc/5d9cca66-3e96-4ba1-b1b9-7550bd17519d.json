{
    "summary": "This code manages AI framework components and database operations, updating reference strength values in the library. It performs analogy in a recommendation system using pattern matching algorithms to handle ports. The `relateTransfer` method prepares data, inserts transfer ports into scene nodes, and adds new ports to arrays if needed.",
    "details": [
        {
            "comment": "This code is from the \"AINetUtils.m\" file in a project called \"SMG_NothingIsAll\". It defines two methods, \"checkCanOutput:\" and \"setCanOutput:\", for managing the output capabilities of data sources in a system. The methods involve interacting with a database or configuration file to determine if a given data source is allowed to produce output, and setting the output capabilities for a data source respectively.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":0-34",
            "content": "//\n//  AINetUtils.m\n//  SMG_NothingIsAll\n//\n//  Created by jiaxiaogang on 2018/9/30.\n//  Copyright \u00a9 2018\u5e74 XiaoGang. All rights reserved.\n//\n#import \"AINetUtils.h\"\n#import \"AIKVPointer.h\"\n#import \"AIPort.h\"\n#import \"XGRedisUtil.h\"\n#import \"NSString+Extension.h\"\n#import \"AIAbsAlgNode.h\"\n#import \"AINetAbsFoNode.h\"\n#import \"AIAbsCMVNode.h\"\n#import \"ThinkingUtils.h\"\n#import \"AINetIndex.h\"\n@implementation AINetUtils\n//MARK:===============================================================\n//MARK:                     < CanOutput >\n//MARK:===============================================================\n+(BOOL) checkCanOutput:(NSString*)identify {\n    AIKVPointer *canout_p = [SMGUtils createPointerForCerebelCanOut];\n    NSArray *arr = [SMGUtils searchObjectForFilePath:canout_p.filePath fileName:kFNDefault time:cRTDefault];\n    return ARRISOK(arr) && [arr containsObject:STRTOOK(identify)];\n}\n+(void) setCanOutput:(NSString*)dataSource {\n    //1. \u53d6mv\u5206\u533a\u7684\u5f15\u7528\u5e8f\u5217\u6587\u4ef6;\n    AIKVPointer *canout_p = [SMGUtils createPointerForCerebelCanOut];"
        },
        {
            "comment": "This code snippet initializes an NSMutableArray with search results for a file path, checks if the identifier is already in the array, and if not, adds it to the array and inserts the array into a database. The code also includes two additional methods: one to check if all objects in an array have a certain property value, and another to get the maximum strong value of a node's first port.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":35-63",
            "content": "    NSMutableArray *mArr = [[NSMutableArray alloc] initWithArray:[SMGUtils searchObjectForFilePath:canout_p.filePath fileName:kFNDefault time:cRTDefault]];\n    NSString *identifier = STRTOOK(dataSource);\n    if (![mArr containsObject:identifier]) {\n        [mArr addObject:identifier];\n        [SMGUtils insertObject:mArr rootPath:canout_p.filePath fileName:kFNDefault time:cRTDefault saveDB:true];\n    }\n}\n//MARK:===============================================================\n//MARK:                     < Other >\n//MARK:===============================================================\n+(BOOL) checkAllOfOut:(NSArray*)conAlgs{\n    if (ARRISOK(conAlgs)) {\n        for (AIAbsAlgNode *checkNode in conAlgs) {\n            if (!checkNode.pointer.isOut) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n+(NSInteger) getConMaxStrong:(AINodeBase*)node{\n    NSInteger result = 1;\n    if (node) {\n        AIPort *firstPort = ARR_INDEX([self conPorts_All:node], 0);\n        if (firstPort) result = firstPort.strong.value + 1;"
        },
        {
            "comment": "This code contains utility functions for working with AI nodes and ports. It retrieves maximum strong values from a list of ports, gets the strength between two nodes, and checks if a pointer is a virtual MV node.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":64-99",
            "content": "    }\n    return result;\n}\n+(NSInteger) getMaxStrong:(NSArray*)ports{\n    NSInteger result = 1;\n    ports = ARRTOOK(ports);\n    for (AIPort *port in ports) {\n        if (port.strong.value > result) {\n            result = port.strong.value;\n        }\n    }\n    return result;\n}\n/**\n *  MARK:--------------------\u83b7\u53d6absNode\u88abconNode\u6307\u5411\u7684\u5f3a\u5ea6--------------------\n */\n+(NSInteger) getStrong:(AINodeBase*)absNode atConNode:(AINodeBase*)conNode type:(AnalogyType)type{\n    if (absNode && conNode) {\n        NSArray *absPorts = [AINetUtils absPorts_All:conNode type:type];\n        AIPort *absPort = [AINetUtils findPort:absNode.pointer fromPorts:absPorts];\n        if (absPort) return absPort.strong.value;\n    }\n    return 0;\n}\n/**\n *  MARK:--------------------\u662f\u5426\u865amv--------------------\n *  @desc \u865amv\u5224\u65ad\u6807\u51c6 (\u8feb\u5207\u5ea6\u662f\u5426\u4e3a0);\n *  @status 2022.11.10: \u5e94\u8be5\u65e9\u5c31\u662f\u5f03\u7528\u72b6\u6001,\u6574\u4e2a\u865amv\u529f\u80fd\u5e94\u8be5\u65e9\u6ca1\u7528\u4e86;\n */\n+(BOOL) isVirtualMv:(AIKVPointer*)mv_p{\n    AICMVNodeBase *mv = [SMGUtils searchNode:mv_p];\n    if (mv) {\n        NSInteger urgentTo = [NUMTOOK([AINetIndex getData:mv.urgentTo_p]) integerValue];"
        },
        {
            "comment": "This code appears to be a part of AI framework, containing functions for retrieving values from certain data structures. It has methods to check if a parameter is urgent, get the delta value from an AIKVPointer object, and retrieve the type from an array of nodes in the context of an analogy. The code also includes test functions and error handling.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":100-137",
            "content": "        return urgentTo == 0;\n    }\n    return false;\n}\n/**\n *  MARK:--------------------\u83b7\u53d6mv\u7684delta--------------------\n */\n+(NSInteger) getDeltaFromMv:(AIKVPointer*)mv_p{\n    AICMVNodeBase *mv = [SMGUtils searchNode:mv_p];\n    if (mv) {\n        return [NUMTOOK([AINetIndex getData:mv.delta_p]) integerValue];\n    }\n    return 0;\n}\n//MARK:===============================================================\n//MARK:                     < \u53d6at&ds&type >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u4ececonNodes\u4e2d\u53d6type--------------------\n *  @desc \u5177\u8c61\u662f\u4ec0\u4e48\u7c7b\u578b,\u62bd\u8c61\u5c31\u662f\u4ec0\u4e48\u7c7b\u578b;\n *  @callers \u76ee\u524d\u5728\u5916\u7c7b\u6bd4\u4e2d,\u4efb\u4f55type\u7c7b\u578b\u90fd\u53ef\u80fd\u8c03\u7528;\n */\n+(AnalogyType) getTypeFromConNodes:(NSArray*)conNodes{\n    NSArray *types = [SMGUtils removeRepeat:[SMGUtils convertArr:conNodes convertBlock:^id(AINodeBase *obj) {\n        return @(obj.pointer.type);\n    }]];\n    [AITest test6:types];\n    if (types.count == 1) {\n        return [NUMTOOK(ARR_INDEX(types, 0)) intValue];\n    }\n    return ATDefault;\n}\n/**\n *  MARK:--------------------\u4ececonNodes\u4e2d\u53d6ds--------------------"
        },
        {
            "comment": "This code retrieves the data source (DS) and algorithm type (AT) from a given array of nodes, with a specified type. It checks if the array contains only one element and returns it, otherwise, it returns the default value. This function is used in external comparison, primarily called by GL type.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":138-166",
            "content": " *  @desc \u5177\u8c61\u662f\u4ec0\u4e48\u7c7b\u578b,\u62bd\u8c61\u5c31\u662f\u4ec0\u4e48\u7c7b\u578b;\n *  @callers \u76ee\u524d\u5728\u5916\u7c7b\u6bd4\u4e2d,\u4ec5GL\u7c7b\u578b\u4f1a\u8c03\u7528;\n */\n+(NSString*) getDSFromConNodes:(NSArray*)conNodes type:(AnalogyType)type{\n    if (type == ATGreater || type == ATLess) {\n        NSArray *dsList = [SMGUtils removeRepeat:[SMGUtils convertArr:conNodes convertBlock:^id(AIFoNodeBase *obj) {\n            return obj.pointer.dataSource;\n        }]];\n        [AITest test6:dsList];\n        if (dsList.count == 1) {\n            return ARR_INDEX(dsList, 0);\n        }\n    }\n    return DefaultDataSource;\n}\n/**\n *  MARK:--------------------\u4ececonNodes\u4e2d\u53d6ds--------------------\n *  @desc \u5177\u8c61\u662f\u4ec0\u4e48\u7c7b\u578b,\u62bd\u8c61\u5c31\u662f\u4ec0\u4e48\u7c7b\u578b;\n *  @callers \u76ee\u524d\u5728\u5916\u7c7b\u6bd4\u4e2d,\u4ec5GL\u7c7b\u578b\u4f1a\u8c03\u7528;\n */\n+(NSString*) getATFromConNodes:(NSArray*)conNodes type:(AnalogyType)type{\n    if (type == ATGreater || type == ATLess) {\n        NSArray *atList = [SMGUtils removeRepeat:[SMGUtils convertArr:conNodes convertBlock:^id(AIFoNodeBase *obj) {\n            return obj.pointer.algsType;\n        }]];\n        [AITest test6:atList];\n        if (atList.count == 1) {\n            return ARR_INDEX(atList, 0);"
        },
        {
            "comment": "This code is a method in the class AINetUtils, specifically within the Insert category. It allows for inserting reference ports for all algorithm nodes, taking an array of content pointers and a differential strength parameter. The content pointers are checked for duplicates before sorting and looping through each one to insert into the hard drive node with binary search-based strong sequence insertion.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":167-199",
            "content": "        }\n    }\n    return DefaultAlgsType;\n}\n@end\n@implementation AINetUtils (Insert)\n//MARK:===============================================================\n//MARK:                     < \u5f15\u7528\u63d2\u7ebf (\u5916\u754c\u8c03\u7528,\u652f\u6301alg/fo/mv) >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u6982\u5ff5_\u5f15\u7528_\u5fae\u4fe1\u606f--------------------\n *  @version\n *      2020.08.05: content_ps\u6dfb\u52a0\u53bb\u91cd\u529f\u80fd,\u907f\u514d\u540c\u4e00\u4e2a\"\u5206\"\u4fe1\u606f,\u88ab\u591a\u6b21\u62a5\u5f15\u7528\u5f3a\u5ea6\u53e0\u52a0;\n */\n+(void) insertRefPorts_AllAlgNode:(AIKVPointer*)algNode_p content_ps:(NSArray*)content_ps difStrong:(NSInteger)difStrong{\n    content_ps = [SMGUtils removeRepeat:content_ps];\n    if (algNode_p && ARRISOK(content_ps)) {\n        NSArray *sort_ps = [SMGUtils sortPointers:content_ps];\n        //1. \u904d\u5386value_p\u5fae\u4fe1\u606f,\u6dfb\u52a0\u5f15\u7528;\n        for (AIPointer *value_p in content_ps) {\n            //2. \u786c\u76d8\u7f51\u7edc\u65f6,\u53d6\u51farefPorts -> \u5e76\u4e8c\u5206\u6cd5\u5f3a\u5ea6\u5e8f\u5217\u63d2\u5165 -> \u5b58XGWedis;\n            [self insertRefPorts_HdNode:algNode_p passiveRefValue_p:value_p ps:sort_ps difStrong:difStrong];\n        }\n    }\n}\n/**\n *  MARK:--------------------\u65f6\u5e8f_\u5f15\u7528_\u6982\u5ff5--------------------"
        },
        {
            "comment": "This code is part of a function that inserts reference ports for all FO nodes in an array. It first removes any duplicate elements from the order_ps array to avoid adding redundant information. Then, it iterates through each element and calls itself recursively to insert the reference ports for the corresponding FO node. The code also checks if the searched object is valid before proceeding with the insertion of pointer.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":200-218",
            "content": " *  @version\n *      2020.08.05: order_ps\u6dfb\u52a0\u53bb\u91cd\u529f\u80fd,\u907f\u514d\u540c\u4e00\u4e2a\"\u5206\"\u4fe1\u606f,\u88ab\u591a\u6b21\u62a5\u5f15\u7528\u5f3a\u5ea6\u53e0\u52a0;\n */\n+(void) insertRefPorts_AllFoNode:(AIKVPointer*)foNode_p order_ps:(NSArray*)order_ps ps:(NSArray*)ps {\n    order_ps = [SMGUtils removeRepeat:order_ps];\n    for (AIKVPointer *order_p in ARRTOOK(order_ps)) {\n        [self insertRefPorts_AllFoNode:foNode_p order_p:order_p ps:ps difStrong:1];\n    }\n}\n+(void) insertRefPorts_AllFoNode:(AIKVPointer*)foNode_p order_ps:(NSArray*)order_ps ps:(NSArray*)ps difStrong:(NSInteger)difStrong{\n    order_ps = [SMGUtils removeRepeat:order_ps];\n    for (AIKVPointer *order_p in ARRTOOK(order_ps)) {\n        [self insertRefPorts_AllFoNode:foNode_p order_p:order_p ps:ps difStrong:difStrong];\n    }\n}\n+(void) insertRefPorts_AllFoNode:(AIKVPointer*)foNode_p order_p:(AIKVPointer*)order_p ps:(NSArray*)ps difStrong:(NSInteger)difStrong{\n    AIAlgNodeBase *algNode = [SMGUtils searchObjectForPointer:order_p fileName:kFNNode time:cRTNode(order_p)];\n    if (ISOK(algNode, AIAlgNodeBase.class)) {\n        [AINetUtils insertPointer_Hd:foNode_p toPorts:algNode.refPorts ps:ps difStrong:difStrong];"
        },
        {
            "comment": "This code inserts refPorts of mvNode and its sparse data (delta and urgent) into the network. It first sorts the content pointers, then inserts them into the XGWedis database if the mvNode and value_p are valid. This is a general method for inserting reference ports into the hard disk node using binary search for strength sorting.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":219-241",
            "content": "        [SMGUtils insertObject:algNode pointer:algNode.pointer fileName:kFNNode time:cRTNode(algNode.pointer)];\n    }\n}\n/**\n *  MARK:--------------------mv\u548c\u5b83\u7684\u7a00\u758f\u7801(delta\u548curgent)\u63d2\u7ebf--------------------\n *  @version\n *      2023.06.18: \u652f\u6301ps\u751f\u6210header,\u539f\u6765\u662fnil,\u5bfc\u81f4\u5206\u4e0d\u6e05mv\u548c\u7a7a\u6982\u5ff5 (\u53c2\u800330026-\u4fee\u590d);\n */\n+(void) insertRefPorts_AllMvNode:(AICMVNodeBase*)mvNode value_p:(AIPointer*)value_p difStrong:(NSInteger)difStrong{\n    if (mvNode && value_p) {\n        //0. mv\u7684ps\u4e5f\u4e0d\u4e3anil,\u4f20delta\u548curgent\u751f\u6210 (\u672c\u6765\u8fd9\u4fe9\u5c31\u662f\u5b83\u7684\u5185\u5bb9,\u53ea\u662f\u73b0\u5728\u5355\u72ec\u5b58\u7740\u4e24\u4e2a\u5b57\u6bb5\u800c\u5df2);\n        NSArray *sort_ps = [SMGUtils sortPointers:mvNode.content_ps];\n        //1. \u786c\u76d8\u7f51\u7edc\u65f6,\u53d6\u51farefPorts -> \u5e76\u4e8c\u5206\u6cd5\u5f3a\u5ea6\u5e8f\u5217\u63d2\u5165 -> \u5b58XGWedis;\n        [self insertRefPorts_HdNode:mvNode.pointer passiveRefValue_p:value_p ps:sort_ps difStrong:difStrong];\n    }\n}\n/**\n *  MARK:--------------------\u786c\u76d8\u8282\u70b9_\u5f15\u7528_\u5fae\u4fe1\u606f_\u63d2\u7ebf \u901a\u7528\u65b9\u6cd5--------------------\n */\n+(void) insertRefPorts_HdNode:(AIKVPointer*)hdNode_p passiveRefValue_p:(AIPointer*)passiveRefValue_p ps:(NSArray*)ps difStrong:(NSInteger)difStrong{\n    if (ISOK(hdNode_p, AIKVPointer.class) && ISOK(passiveRefValue_p, AIKVPointer.class)) {"
        },
        {
            "comment": "This code searches for a file path and extracts the corresponding ports, then inserts these ports into another array. The function is called to insert pointers into ports with different strength levels. It checks if the pointer and ports are valid before proceeding.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":242-258",
            "content": "        NSArray *fnRefPorts = ARRTOOK([SMGUtils searchObjectForFilePath:passiveRefValue_p.filePath fileName:kFNRefPorts time:cRTReference]);\n        NSMutableArray *refPorts = [[NSMutableArray alloc] initWithArray:fnRefPorts];\n        [AINetUtils insertPointer_Hd:hdNode_p toPorts:refPorts ps:ps difStrong:difStrong];\n        [SMGUtils insertObject:refPorts rootPath:passiveRefValue_p.filePath fileName:kFNRefPorts time:cRTReference saveDB:true];\n    }\n}\n//MARK:===============================================================\n//MARK:                     < \u901a\u7528 \u4ec5\u63d2\u7ebf\u5230ports >\n//MARK:===============================================================\n+(void) insertPointer_Hd:(AIKVPointer*)pointer toPorts:(NSMutableArray*)ports ps:(NSArray*)ps{\n    [self insertPointer_Hd:pointer toPorts:ports ps:ps difStrong:1];\n}\n+(void) insertPointer_Hd:(AIKVPointer*)pointer toPorts:(NSMutableArray*)ports ps:(NSArray*)ps difStrong:(NSInteger)difStrong{\n    if (ISOK(pointer, AIPointer.class) && ISOK(ports, NSMutableArray.class)) {\n        //1. \u627e\u5230/\u65b0\u5efaport"
        },
        {
            "comment": "Updates the strength of a found port based on differences calculated, performs binary search for inserting the updated port into an array, and logs a warning if the same pointerId is encountered twice in the second sequence.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":259-278",
            "content": "        AIPort *findPort = [self findPort:pointer fromPorts:ports ps:ps];\n        if (!findPort) {\n            return;\n        }\n        //TODOTOMORROW: \u5bf9\u5f3a\u5ea6>100\u7684\u6253\u65ad\u70b9,\u91cd\u65b0\u8bad\u7ec3,\u67e520151-BUG9\u65b9\u5411\u7d22\u5f15\u5f3a\u5ea6\u5f02\u5e38\u7684\u95ee\u9898;\n        if (difStrong > 1 && [kPN_CMV_NODE isEqualToString:pointer.folderName] && findPort.strong.value > 1) {\n            NSLog(@\"------\u5f15\u7528\u5f3a\u5ea6\u5f02\u5e38\u66f4\u65b0 %@_%ld: %ld + %ld = %ld\",findPort.target_p.folderName,findPort.target_p.pointerId,difStrong,findPort.strong.value,findPort.strong.value + difStrong);\n        }\n        //2. \u5f3a\u5ea6\u66f4\u65b0\n        findPort.strong.value += difStrong;\n        //3. \u4e8c\u5206\u63d2\u5165\n        [XGRedisUtil searchIndexWithCompare:^NSComparisonResult(NSInteger checkIndex) {\n            AIPort *checkPort = ARR_INDEX(ports, checkIndex);\n            return [SMGUtils comparePortA:findPort portB:checkPort];\n        } startIndex:0 endIndex:ports.count - 1 success:^(NSInteger index) {\n            NSLog(@\"\u8b66\u544a!!! bug:\u5728\u7b2c\u4e8c\u5e8f\u5217\u7684ports\u4e2d\u53d1\u73b0\u4e86\u4e24\u6b21port\u76ee\u6807___pointerId\u4e3a:%ld\",(long)findPort.target_p.pointerId);\n        } failure:^(NSInteger index) {"
        },
        {
            "comment": "This code searches for a port and if found, removes it from the ports array. If not found, creates a new port with the given pointer and header information. The method takes an AIKVPointer object, a mutable array of AIPort objects, and an NSArray of pointers as parameters. It returns an AIPort object.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":279-309",
            "content": "            if (ARR_INDEXISOK(ports, index)) {\n                [ports insertObject:findPort atIndex:index];\n            }else{\n                [ports addObject:findPort];\n            }\n        }];\n    }\n}\n//MARK:===============================================================\n//MARK:                     < \u627e\u51faport >\n//MARK:===============================================================\n//\u627e\u51faport (\u5e76\u4eceports\u4e2d\u79fb\u9664 & \u65e0\u5219\u65b0\u5efa);\n+(AIPort*) findPort:(AIKVPointer*)pointer fromPorts:(NSMutableArray*)fromPorts ps:(NSArray*)ps{\n    if (ISOK(pointer, AIPointer.class) && ISOK(fromPorts, NSMutableArray.class)) {\n        //1. \u627e\u51fa\u65e7\u6709;\n        AIPort *findPort = [self findPort:pointer fromPorts:fromPorts];\n        if (findPort) [fromPorts removeObject:findPort];\n        //2. \u65e0\u5219\u65b0\u5efaport;\n        if (!findPort) {\n            findPort = [[AIPort alloc] init];\n            findPort.target_p = pointer;\n            findPort.header = [NSString md5:[SMGUtils convertPointers2String:ps]];\n        }\n        return findPort;\n    }\n    return nil;\n}\n//\u627e\u51faport"
        },
        {
            "comment": "This code contains functions for relating abstract nodes with concrete nodes and testing. It defines methods for relating alg/fo/mv abs nodes with con nodes, copies arrays, finds ports, and tests method 25 on absNode conAlgs.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":310-332",
            "content": "+(AIPort*) findPort:(AIKVPointer*)pointer fromPorts:(NSArray*)fromPorts{\n    fromPorts = ARRTOOK(fromPorts);\n    NSArray *cp = [fromPorts copy];\n    for (AIPort *port in cp) {\n        if ([port.target_p isEqual:pointer]) {\n            return port;\n        }\n    }\n    return nil;\n}\n//MARK:===============================================================\n//MARK:                     < \u62bd\u5177\u8c61\u5173\u8054 Relate (\u5916\u754c\u8c03\u7528,\u652f\u6301alg/fo) >\n//MARK:===============================================================\n+(void) relateAlgAbs:(AIAlgNodeBase*)absNode conNodes:(NSArray*)conNodes isNew:(BOOL)isNew{\n    [self relateGeneralAbs:absNode absConPorts:absNode.conPorts conNodes:conNodes isNew:isNew difStrong:1];\n    [AITest test25:absNode conAlgs:conNodes];\n}\n+(void) relateFoAbs:(AIFoNodeBase*)absNode conNodes:(NSArray*)conNodes isNew:(BOOL)isNew{\n    [self relateGeneralAbs:absNode absConPorts:absNode.conPorts conNodes:conNodes isNew:isNew difStrong:1];\n}\n+(void) relateMvAbs:(AIAbsCMVNode*)absNode conNodes:(NSArray*)conNodes isNew:(BOOL)isNew{"
        },
        {
            "comment": "This code is defining a method that relates a general abstract node with a set of concrete nodes. It takes in the abstract node, its associated ports, and an array of concrete nodes to relate. The method iterates through each concrete node, skipping any that are equal to the abstract node. If the difference between the maximum strong port count and the current node's strong port count is 1, it performs a specific relation for SP nodes, otherwise it does a general relation.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":333-355",
            "content": "    [self relateGeneralAbs:absNode absConPorts:absNode.conPorts conNodes:conNodes isNew:isNew difStrong:1];\n}\n+(void) relateFoAbs:(AINetAbsFoNode*)absNode conNodes:(NSArray*)conNodes isNew:(BOOL)isNew strongPorts:(NSArray*)strongPorts{\n    NSInteger difStrong = [self getMaxStrong:strongPorts];\n    [self relateGeneralAbs:absNode absConPorts:absNode.conPorts conNodes:conNodes isNew:isNew difStrong:difStrong];\n}\n/**\n *  MARK:--------------------\u62bd\u5177\u8c61\u5173\u8054\u901a\u7528\u65b9\u6cd5--------------------\n *  @param absConPorts : notnull\n *  @param isNew : absNode\u662f\u5426\u4e3a\u65b0\u6784\u5efa;\n *  @version\n *      2021.01.11: \u5f53SP\u8282\u70b9\u65f6,difStrong\u4e3a1 (\u53c2\u800322032);\n */\n+(void) relateGeneralAbs:(AINodeBase*)absNode absConPorts:(NSMutableArray*)absConPorts conNodes:(NSArray*)conNodes isNew:(BOOL)isNew difStrong:(NSInteger)difStrong{\n    if (ISOK(absNode, AINodeBase.class)) {\n        //1. \u5177\u8c61\u8282\u70b9\u7684 \u5173\u8054&\u5b58\u50a8\n        conNodes = ARRTOOK(conNodes);\n        for (AINodeBase *conNode in conNodes) {\n            //1. con\u4e0eabs\u5fc5\u987b\u4e0d\u540c;\n            if ([absNode isEqual:conNode]) continue;\n            NSArray *absContent_ps = absNode.content_ps;"
        },
        {
            "comment": "Calculates the maximum strong from connected nodes, inserts abstract ports into concrete nodes and vice versa, then stores the resulting objects.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":356-381",
            "content": "            NSArray *conContent_ps = conNode.content_ps;\n            //2. \u8ba1\u7b97disStrong (\u9ed8\u8ba4\u4e3a1 & \u5f53\u65b0\u8282\u70b9\u4e14\u4e0d\u662fSP\u65f6\u4ece\u5177\u8c61\u53d6maxStrong);\n            AnalogyType type = absNode.pointer.type;//DS2ATType(absNode.pit.ds);\n            if (isNew && type != ATSub && type != ATPlus) {\n                difStrong = [self getConMaxStrong:conNode];\n            }\n            //2. hd_\u5177\u8c61\u8282\u70b9\u63d2\"\u62bd\u8c61\u7aef\u53e3\";\n            [AINetUtils insertPointer_Hd:absNode.pointer toPorts:conNode.absPorts ps:absContent_ps difStrong:difStrong];\n            //3. hd_\u62bd\u8c61\u8282\u70b9\u63d2\"\u5177\u8c61\u7aef\u53e3\";\n            [AINetUtils insertPointer_Hd:conNode.pointer toPorts:absConPorts ps:conContent_ps difStrong:difStrong];\n            //4. hd_\u5b58\u50a8\n            [SMGUtils insertObject:conNode pointer:conNode.pointer fileName:kFNNode time:cRTNode(conNode.pointer)];\n        }\n        //7. \u62bd\u8c61\u8282\u70b9\u7684 \u5173\u8054&\u5b58\u50a8\n        [SMGUtils insertNode:absNode];\n    }\n}\n/**\n *  MARK:--------------------\u62bd\u5177\u8c61\u5173\u8054\u901a\u7528\u65b9\u6cd5 (\u53c2\u800329031-todo3)--------------------\n */\n+(void) relateGeneralCon:(AINodeBase*)conNode absNodes:(NSArray*)absNode_ps {\n    //1. \u6570\u636e\u51c6\u5907;"
        },
        {
            "comment": "This code is associating an abstract node (absNode) with a concrete node (conNode) by inserting their respective ports into each other's content and storing them.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":382-410",
            "content": "    absNode_ps = ARRTOOK(absNode_ps);\n    if (!ISOK(conNode, AINodeBase.class)) return;\n    //2. \u4f9d\u6b21\u5173\u8054;\n    for (AIKVPointer *absNode_p in absNode_ps) {\n        //1. con\u4e0eabs\u5fc5\u987b\u4e0d\u540c;\n        AINodeBase *absNode = [SMGUtils searchNode:absNode_p];\n        if ([conNode isEqual:absNode]) continue;\n        //2. hd_\u5177\u8c61\u8282\u70b9\u63d2\"\u62bd\u8c61\u7aef\u53e3\";\n        [AINetUtils insertPointer_Hd:absNode.pointer toPorts:conNode.absPorts ps:absNode.content_ps difStrong:1];\n        //3. hd_\u62bd\u8c61\u8282\u70b9\u63d2\"\u5177\u8c61\u7aef\u53e3\";\n        [AINetUtils insertPointer_Hd:conNode.pointer toPorts:absNode.conPorts ps:conNode.content_ps difStrong:1];\n        //4. hd_\u5b58\u50a8\n        [SMGUtils insertNode:absNode];\n        [SMGUtils insertNode:conNode];\n    }\n}\n/**\n *  MARK:--------------------cmv\u57fa\u672c\u6a21\u578b--------------------\n *  @version\n *      2022.05.11: cmv\u6a21\u578brelate\u65f6,\u5c06foNode\u7684content.refPort\u6807\u8bb0mv\u6307\u5411 (\u53c2\u800326022-2);\n *      2023.08.11: mv\u652f\u6301\u591a\u4e2a\u6307\u5411foNode (\u53c2\u800330095-todo2);\n */\n+(void) relateFo:(AIFoNodeBase*)foNode mv:(AICMVNodeBase*)mvNode{\n    if (foNode && mvNode) {\n        //1. \u4e92\u6307\u5411\n        [AINetUtils insertPointer_Hd:foNode.pointer toPorts:mvNode.foPorts ps:foNode.content_ps difStrong:1];"
        },
        {
            "comment": "This code appears to be a part of a class called \"AINetUtils\". It seems to define methods related to \"Ports\" for the class. The code includes implementations for finding all ports, filtering normal ports, and finding ports with specific types. It also includes a method that inserts nodes into some sort of storage or database. Overall, this code appears to be involved in managing and organizing data about different types of ports within a network system.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":411-444",
            "content": "        foNode.cmvNode_p = mvNode.pointer;\n        //2. \u5bf9content.refPort\u6807\u8bb0mv;\n        [AINetUtils maskHavMv_AlgWithFo:foNode];\n        //3. \u5b58\u50a8foNode & cmvNode\n        [SMGUtils insertNode:mvNode];\n        [SMGUtils insertNode:foNode];\n    }\n}\n@end\n//MARK:===============================================================\n//MARK:                     < Port >\n//MARK:===============================================================\n@implementation AINetUtils (Port)\n+(NSArray*) absPorts_All:(AINodeBase*)node{\n    NSMutableArray *allPorts = [[NSMutableArray alloc] init];\n    if (ISOK(node, AINodeBase.class)) {\n        [allPorts addObjectsFromArray:node.absPorts];\n    }\n    return allPorts;\n}\n+(NSArray*) absPorts_All_Normal:(AINodeBase*)node{\n    NSArray *allPorts = [self absPorts_All:node];\n    return [SMGUtils filterPorts_Normal:allPorts];\n}\n+(NSArray*) absPorts_All:(AINodeBase*)node type:(AnalogyType)type{\n    return [self absPorts_All:node havTypes:@[@(type)] noTypes:nil];\n}\n+(NSArray*) absPorts_All:(AINodeBase*)node havTypes:(NSArray*)havTypes noTypes:(NSArray*)noTypes{"
        },
        {
            "comment": "This code appears to be a part of an AI foundation library. It defines various methods for handling ports in a network, including filtering and organizing them based on their types. The methods include absPorts_All, conPorts_All, absAndMePits, and filterPorts_Normal. These methods seem to handle different aspects of working with ports in the AI network model.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":445-468",
            "content": "    NSArray *allPorts = [self absPorts_All:node];\n    return [SMGUtils filterPorts:allPorts havTypes:havTypes noTypes:noTypes];\n}\n+(NSArray*) absAndMePits:(AINodeBase*)node{\n    NSMutableArray *result = [[NSMutableArray alloc] initWithObjects:node.pointer, nil];\n    [result addObjectsFromArray:Ports2Pits([self absPorts_All:node])];\n    return result;\n}\n+(NSArray*) conPorts_All:(AINodeBase*)node{\n    NSMutableArray *allPorts = [[NSMutableArray alloc] init];\n    if (ISOK(node, AIAbsAlgNode.class)) {\n        [allPorts addObjectsFromArray:((AIAbsAlgNode*)node).conPorts];\n    }else if (ISOK(node, AINetAbsFoNode.class)) {\n        [allPorts addObjectsFromArray:((AINetAbsFoNode*)node).conPorts];\n    }\n    return allPorts;\n}\n+(NSArray*) conPorts_All_Normal:(AINodeBase*)node{\n    NSArray *allPorts = [self conPorts_All:node];\n    return [SMGUtils filterPorts_Normal:allPorts];\n}\n+(NSArray*) conPorts_All:(AINodeBase*)node havTypes:(NSArray*)havTypes noTypes:(NSArray*)noTypes{\n    NSArray *allPorts = [self conPorts_All:node];"
        },
        {
            "comment": "This code is part of a larger project and appears to be related to filtering and collecting ports, specifically refPorts, in the AIAlgNodeBase class. The code contains two methods: \"refPorts_All4Alg\" and \"refPorts_All4Alg_Normal\". The former method initializes an array of all ports, checks if the node is valid, and adds the node's refPorts to the array. It also includes a check for empty elements in refPorts to prevent crashes. The latter method simply returns the result of calling \"refPorts_All4Alg\".",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":469-496",
            "content": "    return [SMGUtils filterPorts:allPorts havTypes:havTypes noTypes:noTypes];\n}\n/**\n *  MARK:--------------------refPorts--------------------\n *  @version\n *      2022.08.22: \u56e0\u4e3a\u9632\u91cd\u6027\u80fd\u5dee,\u4f18\u5316\"\u5e76\u96c6\"\u9632\u91cd\u7b97\u6cd5 (\u53c2\u800327082-\u6162\u4ee3\u78011);\n *      2022.10.09: \u4ec5\u4fdd\u7559\u786c\u76d8\u7684refPorts (\u53c2\u800327124-todo4);\n */\n+(NSArray*) refPorts_All4Alg:(AIAlgNodeBase*)node{\n    NSMutableArray *allPorts = [[NSMutableArray alloc] init];\n    if (ISOK(node, AIAlgNodeBase.class)) {\n        //2023.11.29: refPorts\u4e2d\u6709\u7a7a\u5143\u7d20,\u5bfc\u81f4\u95ea\u9000...\n        for (NSInteger i = 0; i < node.refPorts.count; i++) {\n            AIPort *item = ARR_INDEX(node.refPorts, i);\n            if (!item) {\n                AIFoNodeBase *itemNode = [SMGUtils searchNode:item.target_p];\n                ELog(@\"\u4ee5\u524d\u6ca1\u7a7a\u8fc7,\u7a81\u7136\u8fd9\u91cc\u95ea\u9000\u4e86,\u4f46\u4e0d\u590d\u73b0,\u4ee5\u540e\u590d\u73b0\u65f6\u65ad\u70b9\u5728\u8fd9\u91cc,\u67e5\u4e0b\u539f\u56e0:%@ %@ %ld/%ld\",Alg2FStr(node),Fo2FStr(itemNode),i,node.refPorts.count);\n                NSLog(@\"\");\n            }\n        }\n        [allPorts addObjectsFromArray:node.refPorts];\n    }\n    return allPorts;\n}\n+(NSArray*) refPorts_All4Alg_Normal:(AIAlgNodeBase*)node{\n    NSArray *allPorts = [self refPorts_All4Alg:node];"
        },
        {
            "comment": "This code filters the ports of a given node and returns a new array containing only the reference ports. If the node is a value, it searches for the reference ports in the file system. For algorithm nodes, it iterates through their content's reference ports and marks the ones that are equal to the current foNode pointer as true.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":497-526",
            "content": "    return [SMGUtils filterPorts_Normal:allPorts];\n}\n+(NSArray*) refPorts_All:(AIKVPointer*)node_p{\n    if (PitIsValue(node_p)) {\n        return [self refPorts_All4Value:node_p];\n    }else if(PitIsAlg(node_p)){\n        return [self refPorts_All4Alg:[SMGUtils searchNode:node_p]];\n    }\n    return nil;\n}\n+(NSArray*) refPorts_All4Value:(AIKVPointer*)value_p {\n    if (!value_p) return nil;\n    return [SMGUtils searchObjectForFilePath:value_p.filePath fileName:kFNRefPorts time:cRTReference];\n}\n/**\n *  MARK:--------------------\u5bf9fo.content.refPort\u6807\u8bb0havMv--------------------\n *  @desc \u6839\u636efo\u6807\u8bb0alg.refPort\u7684havMv (\u53c2\u800326022-2);\n */\n+(void) maskHavMv_AlgWithFo:(AIFoNodeBase*)foNode{\n    //1. \u6807\u8bb0alg.refPort;\n    for (AIKVPointer *alg_p in foNode.content_ps) {\n        AIAlgNodeBase *algNode = [SMGUtils searchNode:alg_p];\n        NSArray *algRefPorts = [AINetUtils refPorts_All4Alg:algNode];\n        for (AIPort *algRefPort in algRefPorts) {\n            //2. \u5f53refPort\u662f\u5f53\u524dfo,\u5219\u6807\u8bb0\u4e3atrue;\n            if ([algRefPort.target_p isEqual:foNode.pointer]) {"
        },
        {
            "comment": "Code snippet marks a value's reference ports with havMv in AIAlgNodeBase and saves the refPorts to db. It loops through each value_p, checks if its target is the current algNode, and sets the targetHavMv to true. The code also inserts the valueRefPorts into the database.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":527-556",
            "content": "                algRefPort.targetHavMv = true;\n                //3. \u4fdd\u5b58algRefPorts\u5230db;\n                [SMGUtils insertNode:algNode];\n                //4. \u7ee7\u7eed\u5411\u5fae\u89c2\u6807\u8bb0;\n                [self maskHavMv_ValueWithAlg:algNode];\n            }\n        }\n    }\n}\n/**\n *  MARK:--------------------\u5bf9alg.content.refPort\u6807\u8bb0havMv--------------------\n *  @desc \u6839\u636ealg\u6807\u8bb0value.refPort\u7684havMv (\u53c2\u800326022-2);\n *  @test \u53d6\u4e86db+mem\u7684refPorts,\u4f46\u4fdd\u5b58\u65f6,\u90fd\u4fdd\u5b58\u5230\u4e86db\u4e2d (\u4f46\u5e94\u8be5\u6ca1\u5565\u5f71\u54cd,\u5148\u4e0d\u7ba1);\n *  @version\n *      2022.05.13: \u5c06refPorts_All4Value()\u4e2d\u9632\u91cd\u5904\u7406,\u907f\u514d\u6b64\u5904\u5b58\u5230db\u540e\u6709\u91cd\u590d (\u53c2\u800326023);\n */\n+(void) maskHavMv_ValueWithAlg:(AIAlgNodeBase*)algNode{\n    //1. \u6807\u8bb0value.refPort;\n    for (AIKVPointer *value_p in algNode.content_ps) {\n        NSArray *valueRefPorts = [AINetUtils refPorts_All4Value:value_p];\n        for (AIPort *valueRefPort in valueRefPorts) {\n            //2. \u5f53refPort\u662f\u5f53\u524dalg,\u5219\u6807\u8bb0\u4e3atrue;\n            if ([valueRefPort.target_p isEqual:algNode.pointer]) {\n                valueRefPort.targetHavMv = true;\n                //3. \u4fdd\u5b58valueRefPorts\u5230db;\n                [SMGUtils insertObject:valueRefPorts rootPath:value_p.filePath fileName:kFNRefPorts time:cRTReference saveDB:true];"
        },
        {
            "comment": "This function `getCutIndexByIndexDic` returns the cut index by taking a dictionary `indexDic`. It checks for an existing cut point by considering two methods: taking the maximum key value or finding the protoFo's endpoint. This function returns the abstract Fo's cut point, as concrete cuts do not exist in time-series recognition.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":557-590",
            "content": "            }\n        }\n    }\n}\n@end\n//MARK:===============================================================\n//MARK:                     < Node >\n//MARK:===============================================================\n@implementation AINetUtils (Node)\n/**\n *  MARK:--------------------\u83b7\u53d6cutIndex--------------------\n *  @title \u6839\u636eindexDic\u53d6\u5f97\u622a\u70b9cutIndex (\u53c2\u800327177-todo2);\n *  @desc\n *      1. \u5df2\u53d1\u751f\u622a\u70b9 (\u542bcutIndex\u5df2\u53d1\u751f,\u6240\u4ee5cutIndex\u5e94\u8be5\u5c31\u662fproto\u672b\u4f4d\u5728assFo\u4e2d\u5339\u914d\u5230\u7684assIndex\u4e0b\u6807);\n *      2. \u53d6\u7528\u65b9\u5f0f1: \u53d6\u6700\u5927\u7684key\u5373\u662fcutIndex (\u76ee\u524d\u9009\u7528,\u56e0\u4e3a\u5b83\u7701\u5f97\u53d6\u51faconFo);\n *      3. \u53d6\u7528\u65b9\u5f0f2: \u53d6protoFo\u672b\u4f4d\u4e3avalue,\u5bf9\u5e94\u7684key\u5373\u4e3a:cutIndex;\n *  @version\n *      2023.07.11: v2-\u6839\u636eprotoOrRegroupCutIndex\u5728indexDic\u4e2d\u53d6absMatchFo.cutIndex\u5e76\u8fd4\u56de;\n *  @result \u8fd4\u56de\u622a\u70b9cutIndex (\u6ce8: \u6b64\u5904\u6c38\u8fdc\u8fd4\u56de\u62bd\u8c61Fo\u7684\u622a\u70b9,\u56e0\u4e3a\u5177\u8c61\u5728\u65f6\u5e8f\u8bc6\u522b\u4e2d\u6ca1\u622a\u70b9);\n */\n+(NSInteger) getCutIndexByIndexDic:(NSDictionary*)indexDic {\n    //1. \u53d6indexDic;\n    NSInteger result = -1;\n    indexDic = DICTOOK(indexDic);\n    //2. \u53d6\u6700\u5927\u7684key,\u5373\u4e3acutIndex;\n    for (NSNumber *absIndex in indexDic.allKeys) {\n        if (result < absIndex.integerValue) result = absIndex.integerValue;\n    }\n    return result;"
        },
        {
            "comment": "This function `getCutIndexByIndexDicV2` finds the index most near to a given value in a dictionary, and returns it as the cut index. If not found, it returns -1. The code can be used for cases where there are clear absFo and conFo values.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":591-621",
            "content": "}\n+(NSInteger) getCutIndexByIndexDicV2:(NSDictionary*)indexDic protoOrRegroupCutIndex:(NSInteger)protoOrRegroupCutIndex {\n    //1. \u627e\u51fa<=\u4e14\u6700\u63a5\u8fd1protoOrRegroupCutIndex\u7684value;\n    NSInteger mostNear = -1;\n    for (NSNumber *value in indexDic.allValues) {\n        NSInteger conIndex = value.integerValue;\n        //2. \u5f53\u524dconIndex\u5927\u4e8e\u5df2\u77e5 & \u4e14<=protoOrRegroupCutIndex(\u5fc5\u987b<=\u5df2\u53d1\u751f);\n        if (conIndex > mostNear && conIndex <= protoOrRegroupCutIndex) {\n            mostNear = conIndex;\n        }\n    }\n    //2. mostNear\u5bf9\u5e94\u7684absIndex\u5c31\u662f\u8981\u8fd4\u56de\u7684cutIndex;\n    for (NSNumber *key in indexDic.allKeys) {\n        NSInteger conIndex = NUMTOOK([indexDic objectForKey:key]).integerValue;\n        if (conIndex == mostNear) {\n            return key.integerValue;\n        }\n    }\n    //3. \u5982\u679c\u4e00\u6761\u6ca1\u627e\u7740,\u8bf4\u660ematchFo\u4e00\u5e27\u90fd\u6ca1\u5df2\u53d1\u751f;\n    return -1;\n}\n/**\n *  MARK:--------------------\u83b7\u53d6near\u6570\u636e (\u76f4\u4f20fo\u7248)--------------------\n *  @desc \u8c03\u7528\u8bf4\u660e: \u5bf9\u4e8e\u6709\u660e\u786e\u7684absFo\u548cconFo\u7684,\u53ef\u4ee5\u8c03\u7528fo\u7248;\n *  @desc \u6839\u636eindexDic\u53d6\u5f97nearCount&sumNear (\u53c2\u800327177-todo3);\n *  @version\n *      2023.01.18: \u76f8\u4f3c\u5ea6\u9ed8\u8ba4\u503c\u4e3a1,\u4e14\u76f8\u4f3c\u5ea6\u6539\u4e3a\u76f8\u4e58 (\u53c2\u800328035-todo2);"
        },
        {
            "comment": "This code defines two methods, `getMatchByIndexDic` and `getNearDataByIndexDic`. The first method returns a CGFloat value based on the provided index dictionary, abstract (absFo) and conditional (conFo) pointers, and whether the caller is an abstract. It retrieves the data from the second method, which takes an index dictionary, absFo and conFo pointers, and a boolean for whether the caller is abstract. The method searches for AIFoNodeBase nodes using SMGUtils and then calls another method `getNearDataByIndexDic` with callback functions to get the data for the abstract and conditional fo values. The `getNearDataByIndexDic` method returns an array of near data based on the provided index dictionary, pointers, and whether the caller is abstract.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":622-639",
            "content": " *  @param callerIsAbs : \u8c03\u7528\u8005\u662f\u5426\u662f\u62bd\u8c61;\n *  @result notnull \u5fc5\u6709\u4e24\u4e2a\u5143\u7d20,\u683c\u5f0f\u4e3a: [nearCount, sumNear],\u4e8c\u8005\u90fd\u662f0\u65f6,\u5219\u4e3a\u65e0\u6548\u8fd4\u56de;\n */\n+(CGFloat) getMatchByIndexDic:(NSDictionary*)indexDic absFo:(AIKVPointer*)absFo_p conFo:(AIKVPointer*)conFo_p callerIsAbs:(BOOL)callerIsAbs {\n    return NUMTOOK(ARR_INDEX([self getNearDataByIndexDic:indexDic absFo:absFo_p conFo:conFo_p callerIsAbs:callerIsAbs], 1)).floatValue;\n}\n+(NSArray*) getNearDataByIndexDic:(NSDictionary*)indexDic absFo:(AIKVPointer*)absFo_p conFo:(AIKVPointer*)conFo_p callerIsAbs:(BOOL)callerIsAbs{\n    AIFoNodeBase *absFo = [SMGUtils searchNode:absFo_p];//400ms 4000\u6b21\n    AIFoNodeBase *conFo = [SMGUtils searchNode:conFo_p];//400ms 4000\u6b21\n    return [self getNearDataByIndexDic:indexDic getAbsAlgBlock:^AIKVPointer *(NSInteger absIndex) {\n        return ARR_INDEX(absFo.content_ps, absIndex);\n    } getConAlgBlock:^AIKVPointer *(NSInteger conIndex) {\n        return ARR_INDEX(conFo.content_ps, conIndex);\n    } callerIsAbs:callerIsAbs];\n}\n/**\n *  MARK:--------------------\u83b7\u53d6near\u6570\u636e (\u56de\u8c03\u7248)--------------------"
        },
        {
            "comment": "This method retrieves near data by index dictionary and provides callback functions for getting abstract and concrete algorithm elements. It calculates the total similarity count and sum of similarities for each key-value pair in the index dictionary. If the caller is an abstraction, it gets the near value from the abstract algorithm element.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":640-661",
            "content": " *  @desc \u8c03\u7528\u8bf4\u660e: \u5bf9\u4e8e\u672a\u751f\u6210\u660e\u786e\u7684absFo\u6216conFo\u7684\u8c03\u7528\u56de\u8c03\u7248 (\u6bd4\u5982: canset\u5728transferAlg\u65f6,\u8fd8\u6ca1\u6709\u751f\u6210\u4e3afo\u4f9b\u4f20\u53c2,\u6b64\u5904\u7528\u56de\u8c03\u53bb\u53d6Alg\u5143\u7d20);\n *  @param indexDic \u6839\u636e\u6b64dic\u9010\u6761\u53d6itemNear\u6570\u636e;\n *  @param getAbsAlgBlock : \u6839\u636eabsIndex\u53d6\u5bf9\u5e94\u7684absAlg\u56de\u8c03\n *  @param getConAlgBlock : \u6839\u636econIndex\u53d6\u5bf9\u5e94\u7684conAlg\u56de\u8c03\n */\n+(NSArray*) getNearDataByIndexDic:(NSDictionary*)indexDic getAbsAlgBlock:(AIKVPointer*(^)(NSInteger absIndex))getAbsAlgBlock getConAlgBlock:(AIKVPointer*(^)(NSInteger conIndex))getConAlgBlock callerIsAbs:(BOOL)callerIsAbs {\n    //1. \u6570\u636e\u51c6\u5907;\n    int nearCount = 0;  //\u603b\u76f8\u8fd1\u6570 (\u5339\u914d\u503c<1)\n    indexDic = DICTOOK(indexDic);\n    CGFloat sumNear = indexDic.count > 0 ? 1 : 0;//\u603b\u76f8\u8fd1\u5ea6 (\u6709\u6570\u636e\u65f6\u9ed8\u8ba41,\u65e0\u6570\u636e\u65f6\u9ed8\u8ba40);\n    //2. \u9010\u4e2a\u7edf\u8ba1;\n    for (NSNumber *key in indexDic.allKeys) {\n        NSInteger absIndex = key.integerValue;\n        NSInteger conIndex = NUMTOOK([indexDic objectForKey:key]).integerValue;\n        AIKVPointer *absA_p = getAbsAlgBlock(absIndex);\n        AIKVPointer *conA_p = getConAlgBlock(conIndex);\n        //3. \u590d\u7528\u53d6near\u503c;\n        CGFloat near = 0;\n        if (callerIsAbs) {\n            //5. \u5f53\u524d\u662f\u62bd\u8c61\u65f6_\u4ece\u62bd\u8c61\u53d6\u590d\u7528;"
        },
        {
            "comment": "This code is related to an algorithm for pattern matching and seems to calculate a metric called 'near' using the Absolute and Concrete nodes found from the searchNode function. It also calculates the sum of reference strength based on a dictionary index.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":662-691",
            "content": "            AIAlgNodeBase *absA = [SMGUtils searchNode:absA_p];//590ms 5000\u6b21\n            near = [absA getConMatchValue:conA_p];//100ms 5000\u6b21\n        }else{\n            //4. \u5f53\u524d\u662f\u5177\u8c61\u65f6_\u4ece\u5177\u8c61\u53d6\u590d\u7528;\n            AIAlgNodeBase *conA = [SMGUtils searchNode:conA_p];\n            near = [conA getAbsMatchValue:absA_p];\n        }\n        //7. \u53ea\u8bb0\u5f55near<1\u7684 (\u53d6<1\u7684\u539f\u56e0\u672a\u77e5,\u53c2\u80032619j-todo5);\n        if (near < 1) {\n            [AITest test14:near];\n            sumNear *= near;\n            nearCount++;\n        }\n    }\n    return @[@(nearCount), @(sumNear)];\n}\n//MARK:===============================================================\n//MARK:                     < Fo\u5f15\u7528\u5f3a\u5ea6RefStrong\u7684\u53d6\u503c\u548c\u66f4\u65b0 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u83b7\u53d6sumRefStrong\u5df2\u53d1\u751f\u90e8\u5206\u5f3a\u5ea6--------------------\n *  @desc \u6839\u636eindexDic\u53d6\u5f97sumRefStrong (\u53c2\u80032722f-todo13);\n */\n+(NSInteger) getSumRefStrongByIndexDic:(NSDictionary*)indexDic matchFo:(AIKVPointer*)matchFo_p {\n    //1. \u6570\u636e\u51c6\u5907;\n    NSInteger sumRefStrong = 0;  //\u603b\u5f3a\u5ea6\n    AIFoNodeBase *matchFo = [SMGUtils searchNode:matchFo_p];"
        },
        {
            "comment": "This code contains three functions: `updateRefStrongByIndexDic`, `updateContentStrongByIndexDic`, and a helper function that is not shown. The first two functions update the strength of \"refPort\" and \"contentPort\" based on an index dictionary and a match object, respectively. The third function calculates the total reference strength by iterating through each key in the index dictionary and adding its associated value to a sum.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":693-719",
            "content": "    //2. \u9010\u4e2a\u7edf\u8ba1;\n    for (NSNumber *key in indexDic.allKeys) {\n        NSInteger absIndex = key.integerValue;\n        AIPort *itemPort = ARR_INDEX(matchFo.contentPorts, absIndex);\n        sumRefStrong += itemPort.strong.value;\n    }\n    return sumRefStrong;\n}\n/**\n *  MARK:--------------------\u6839\u636eindexDic\u66f4\u65b0refPort\u5f3a\u5ea6\u503c (\u53c2\u80032722f-todo33)--------------------\n */\n+(void) updateRefStrongByIndexDic:(NSDictionary*)indexDic matchFo:(AIKVPointer*)matchFo_p {\n    //1. \u6839\u636eindexDic\u53d6\u51fa\u5df2\u53d1\u751f\u90e8\u5206content_ps;\n    AIFoNodeBase *matchFo = [SMGUtils searchNode:matchFo_p];\n    NSArray *frontContent_ps = [self filterContentAlgPsByIndexDic:indexDic matchFo:matchFo];\n    //3. \u5c06\u5df2\u53d1\u751f\u90e8\u5206\u589e\u5f3arefStrong;\n    [AINetUtils insertRefPorts_AllFoNode:matchFo_p order_ps:frontContent_ps ps:matchFo.content_ps];\n}\n/**\n *  MARK:--------------------\u6839\u636eindexDic\u66f4\u65b0contentPort\u5f3a\u5ea6\u503c (\u53c2\u80032722f-todo32)--------------------\n */\n+(void) updateContentStrongByIndexDic:(NSDictionary*)indexDic matchFo:(AIKVPointer*)matchFo_p {\n    //1. \u6570\u636e\u51c6\u5907;\n    AIFoNodeBase *matchFo = [SMGUtils searchNode:matchFo_p];"
        },
        {
            "comment": "This code updates the strength value of contentPorts based on indexDic and saves it. It also calculates the sumConStrong by iterating through the indexDic and retrieving matching and canSet nodes.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":721-747",
            "content": "    //2. \u6839\u636eindexDic\u66f4\u65b0contentPort\u5f3a\u5ea6\u503c & \u4fdd\u5b58;\n    for (NSNumber *key in indexDic.allKeys) {\n        NSInteger absIndex = key.integerValue;\n        AIPort *itemPort = ARR_INDEX(matchFo.contentPorts, absIndex);\n        itemPort.strong.value++;\n    }\n    [SMGUtils insertNode:matchFo];\n}\n//MARK:===============================================================\n//MARK:                     < Alg\u62bd\u5177\u8c61\u5f3a\u5ea6ConStrong\u7684\u53d6\u503c\u548c\u66f4\u65b0 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u83b7\u53d6sumConStrong\u5df2\u53d1\u751f\u90e8\u5206\u5f3a\u5ea6--------------------\n *  @desc \u6839\u636eindexDic\u53d6\u5f97sumConStrong (\u53c2\u800328086-todo1);\n */\n+(NSInteger) getSumConStrongByIndexDic:(NSDictionary*)indexDic matchFo:(AIKVPointer*)matchFo_p cansetFo:(AIKVPointer*)cansetFo_p{\n    //1. \u6570\u636e\u51c6\u5907;\n    NSInteger sumStrong = 0;  //\u603b\u5f3a\u5ea6\n    AIFoNodeBase *matchFo = [SMGUtils searchNode:matchFo_p];\n    AIFoNodeBase *cansetFo = [SMGUtils searchNode:cansetFo_p];\n    //2. \u9010\u4e2a\u7edf\u8ba1;\n    for (NSNumber *key in indexDic.allKeys) {\n        NSInteger absIndex = key.integerValue;\n        NSInteger conIndex = NUMTOOK([indexDic objectForKey:key]).integerValue;"
        },
        {
            "comment": "This code updates the strength values of conPorts and absPorts in a canset method. It searches for nodes based on indices, then iterates through an index dictionary to find the corresponding nodes and update their strong values by adding 1. The code assumes that matching and canSet FOs are provided.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":748-769",
            "content": "        AIAlgNodeBase *absAlg = [SMGUtils searchNode:ARR_INDEX(matchFo.content_ps, absIndex)];\n        AIKVPointer *conAlg = ARR_INDEX(cansetFo.content_ps, conIndex);\n        AIPort *findPort = [AINetUtils findPort:conAlg fromPorts:absAlg.conPorts];\n        sumStrong += findPort.strong.value;\n    }\n    return sumStrong;\n}\n/**\n *  MARK:--------------------\u6839\u636eindexDic\u66f4\u65b0conPort\u548cabsPort\u5f3a\u5ea6\u503c--------------------\n *  @desc canset\u65b9\u6848\u6700\u7ec8\u6fc0\u6d3b\u65f6,\u5c06\u5176conPorts\u548cabsPorts\u7684\u5f3a\u5ea6+1 (\u53c2\u800328086-todo2);\n */\n+(void) updateConAndAbsStrongByIndexDic:(NSDictionary*)indexDic matchFo:(AIKVPointer*)matchFo_p cansetFo:(AIKVPointer*)cansetFo_p{\n    //1. \u6570\u636e\u51c6\u5907;\n    AIFoNodeBase *matchFo = [SMGUtils searchNode:matchFo_p];\n    AIFoNodeBase *cansetFo = [SMGUtils searchNode:cansetFo_p];\n    //2. \u5c06\u5df2\u53d1\u751f\u90e8\u5206\u589e\u5f3arefStrong;\n    for (NSNumber *key in indexDic.allKeys) {\n        NSInteger absIndex = key.integerValue;\n        NSInteger conIndex = NUMTOOK([indexDic objectForKey:key]).integerValue;\n        AIAlgNodeBase *absAlg = [SMGUtils searchNode:ARR_INDEX(matchFo.content_ps, absIndex)];"
        },
        {
            "comment": "This code appears to be a part of an algorithm for updating reference strength values in a content-based recommendation system. It searches for nodes based on index dictionary and updates the refPort strength of related algorithms accordingly.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":770-794",
            "content": "        AIAlgNodeBase *conAlg = [SMGUtils searchNode:ARR_INDEX(cansetFo.content_ps, conIndex)];\n        [AINetUtils relateAlgAbs:absAlg conNodes:@[conAlg] isNew:false];\n    }\n}\n//MARK:===============================================================\n//MARK:                     < Alg\u5f15\u7528\u5f3a\u5ea6RefStrong\u66f4\u65b0 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u6839\u636eindexDic\u66f4\u65b0refPort\u5f3a\u5ea6\u503c (\u53c2\u800328103-3)--------------------\n */\n+(void) updateAlgRefStrongByIndexDic:(NSDictionary*)indexDic matchFo:(AIKVPointer*)matchFo_p {\n    //1. \u6839\u636eindexDic\u53d6\u51fa\u5df2\u53d1\u751f\u90e8\u5206content_ps;\n    AIFoNodeBase *matchFo = [SMGUtils searchNode:matchFo_p];\n    NSArray *frontContent_ps = [self filterContentAlgPsByIndexDic:indexDic matchFo:matchFo];\n    //2. \u5c06\u5df2\u53d1\u751f\u90e8\u5206Alg\u589e\u5f3arefStrong;\n    for (AIKVPointer *item in frontContent_ps) {\n        AIAlgNodeBase *itemAlg = [SMGUtils searchNode:item];\n        [AINetUtils insertRefPorts_AllAlgNode:item content_ps:itemAlg.content_ps difStrong:1];\n    }\n}\n//MARK:==============================================================="
        },
        {
            "comment": "This code filters content_ps based on the indexDic and matchFo. It also generates an indexDic mapping for abstract fo and protoFo/assFo in analogy outside.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":795-818",
            "content": "//MARK:                     < PrivateMethod >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u6839\u636eindexDic\u7b5b\u9009fo\u7684content--------------------\n */\n+(NSArray*) filterContentAlgPsByIndexDic:(NSDictionary*)indexDic matchFo:(AIFoNodeBase*)matchFo {\n    //2. \u6839\u636eindexDic\u53d6\u51fa\u5df2\u53d1\u751f\u90e8\u5206content_ps;\n    NSArray *filterContent_ps = [SMGUtils convertArr:indexDic.allKeys convertBlock:^id(NSNumber *key) {\n        NSInteger absIndex = key.integerValue;\n        return ARR_INDEX(matchFo.content_ps, absIndex);\n    }];\n    return filterContent_ps;\n}\n/**\n *  MARK:--------------------\u7c7b\u6bd4\u51faabsFo\u65f6,\u6b64\u5904\u53d6\u5f97\u5177\u8c61fo\u4e0eabsFo\u7684indexDic\u6620\u5c04--------------------\n *  @desc \u4f5c\u75281: \u751f\u6210\u62bd\u8c61canset\u4e0econCanset\u7684indexDic (\u53c2\u800329032-todo1.1)\n *  @desc \u4f5c\u75282: \u751f\u6210\u5916\u7c7b\u6bd4AnalogyOutside()\u91cc\u7684absFo\u4e0eprotoFo/assFo\u7684\u6620\u5c04 (\u53c2\u800329032-todo1.2);\n *  @desc \u6bd4\u5982\u8f93\u5165[3,5,1],\u5219\u8fd4\u56de<1:1, 2:3, 3:5>;\n *  @param conFoIndexes : \u5177\u8c61\u5e27\u7684\u4e0b\u6807\u6570\u7ec4 (\u6bcf\u4e2a\u5143\u7d20,\u90fd\u5bf9\u5e94\u4e86\u62bd\u8c61\u7684\u4e00\u5e27);\n */\n+(NSDictionary*) getIndexDic4AnalogyAbsFo:(NSArray*)conFoIndexes {\n    NSMutableDictionary *result = [NSMutableDictionary new];"
        },
        {
            "comment": "This code sorts the concrete foundation indexes in ascending order, then maps them back to the abstract foundation indexes and extends the sp values from the associated foundation to the abstract foundation. The sorted indexes are used to update the spStrong of the abstract foundation with the corresponding sp value from the associated foundation.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":819-846",
            "content": "    //1. \u5177\u8c61\u4e0b\u6807\u6570\u7ec4\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u4e0b (\u6bd4\u59823,5,1\u6392\u62101,3,5);\n    NSArray *sort = [SMGUtils sortSmall2Big:conFoIndexes compareBlock:^double(NSNumber *obj) {\n        return obj.integerValue;\n    }];\n    //2. \u6839\u636e\u6bcf\u5e27\u6620\u5c04\u751f\u6210indexDic\u7ed3\u679c\u8fd4\u56de;\n    for (NSInteger i = 0; i < sort.count; i++) {\n        [result setObject:ARR_INDEX(sort, i) forKey:@(i)];\n    }\n    return result;\n}\n//MARK:===============================================================\n//MARK:                     < \u62bd\u8c61Fo\u65f6,\u66f4\u65b0SP\u503c >\n//MARK:===============================================================\n/**\n *  MARK:--------------------absFo\u6839\u636eindexDic\u7ee7\u627fconFo\u7684sp\u503c (\u53c2\u800329032-todo2.2)--------------------\n */\n+(void) extendSPByIndexDic:(NSDictionary*)assIndexDic assFo:(AIFoNodeBase*)assFo absFo:(AIFoNodeBase*)absFo {\n    //1. ass\u4e0eabs\u7684\u6bcf\u6761\u6620\u5c04\u90fd\u8981\u7ee7\u627f;\n    for (NSNumber *absIndex in assIndexDic.allKeys) {\n        //2. \u53d6\u51faass\u4e2d\u65e7\u6709\u7684spStrong\u6a21\u578b;\n        NSNumber *assIndex = [assIndexDic objectForKey:absIndex];\n        AISPStrong *spStrong = [assFo.spDic objectForKey:assIndex];\n        //3. \u5c06spStrong\u7ee7\u627f\u7ed9absFo;\n        [absFo updateSPStrong:absIndex.integerValue difStrong:spStrong.sStrong type:ATSub];"
        },
        {
            "comment": "This code appears to be part of a larger class, `AINetUtils`, that deals with AI networking utilities. It includes methods for updating an abstract concept's SP value based on a dictionary of concept indices, and checking if a given concept contains an empty algorithm. The code seems to be written in Objective-C or a similar language.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":847-878",
            "content": "        [absFo updateSPStrong:absIndex.integerValue difStrong:spStrong.pStrong type:ATPlus];\n    }\n}\n/**\n *  MARK:--------------------\u62bd\u8c61fo\u65f6: \u6839\u636eprotoFo\u589e\u5f3aabsFo\u7684SP\u503c+1 (\u53c2\u800329032-todo2.3)--------------------\n */\n+(void) updateSPByIndexDic:(NSDictionary*)conIndexDic conFo:(AIFoNodeBase*)conFo absFo:(AIFoNodeBase*)absFo {\n    for (NSNumber *absIndex in conIndexDic.allKeys) {\n        [absFo updateSPStrong:absIndex.integerValue difStrong:1 type:ATPlus];\n    }\n}\n/**\n *  MARK:--------------------\u5224\u65ad\u65f6\u5e8f\u4e2d\u6709\u7a7a\u6982\u5ff5--------------------\n */\n+(BOOL) foHasEmptyAlg:(AIKVPointer*)fo_p {\n    AIFoNodeBase *fo = [SMGUtils searchNode:fo_p];\n    return [SMGUtils filterSingleFromArr:fo.contentPorts checkValid:^BOOL(AIPort *item) {\n        return [item.header isEqualToString:[NSString md5:@\"\"]];\n    }];\n}\n@end\n//MARK:===============================================================\n//MARK:                     < Canset >\n//MARK:===============================================================\n@implementation AINetUtils (Canset)\n/**\n *  MARK:--------------------\u8fc1\u79fb\u5173\u8054--------------------"
        },
        {
            "comment": "The code defines a method `relateTransfer` that prepares data and inserts transfer ports into scene nodes. It creates two port objects using the provided scenes and cansets, and then checks if each transfer port is already contained in the respective transfer port arrays of the scene nodes. If not, it adds the new port to the array and inserts the scene node back into the system.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AINet/AINetUtils.m\":879-900",
            "content": " */\n+(void) relateTransfer:(AIKVPointer*)absScene absCanset:(AIKVPointer*)absCanset conScene:(AIKVPointer*)conScene conCanset:(AIKVPointer*)conCanset {\n    //1. \u6570\u636e\u51c6\u5907;\n    AIFoNodeBase *absSconeNode = [SMGUtils searchNode:absScene];\n    AIFoNodeBase *conSceneNode = [SMGUtils searchNode:conScene];\n    AITransferPort *absPort = [AITransferPort newWithScene:absScene canset:absCanset];\n    AITransferPort *conPort = [AITransferPort newWithScene:conScene canset:conCanset];\n    //2. \u63d2\u5165\u4f20\u8282\u70b9\u7684\u627f\u7aef\u53e3;\n    if (![absSconeNode.transferConPorts containsObject:conPort]) {\n        [absSconeNode.transferConPorts addObject:conPort];\n        [SMGUtils insertNode:absSconeNode];\n    }\n    //3. \u63d2\u5165\u627f\u8282\u70b9\u7684\u4f20\u7aef\u53e3;\n    if (![conSceneNode.transferAbsPorts containsObject:absPort]) {\n        [conSceneNode.transferAbsPorts addObject:absPort];\n        [SMGUtils insertNode:conSceneNode];\n    }\n}\n@end"
        }
    ]
}