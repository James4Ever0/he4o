{
    "summary": "This code enhances NSArray's description method for improved log string readability. It formats indentation, handles various object types, and adds comma separation. The function generates the final formatted log string.",
    "details": [
        {
            "comment": "This code is an extension of NSArray that adds a custom description method. It increases the indentation level for each array element by adding tabs to the log string. This helps with readability when logging complex data structures. The code also keeps track of tab count variables for dictionaries and sets, suggesting similar functionality may be implemented for those object types as well.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Demo/Foundation+Log.m\":0-40",
            "content": "//\n//  Foundation+Log.m\n//\n//  Created by feiyujie on 2016/12/7.\n//  Copyright \u00a9 2016\u5e74 feiyujie. All rights reserved.\n//\n#ifdef DEBUG\n#import <Foundation/Foundation.h>\nstatic NSInteger dictionaryTabCount = 0;\nstatic NSInteger arrayTabCount = 0;\nstatic NSInteger setTabCount = 0;\n@implementation NSArray(Log)\n- (NSString *)descriptionWithLocale:(id)locale\n{\n    NSString *logStr = [self yj_description:++arrayTabCount];\n    arrayTabCount = 0;\n    return logStr;\n}\n- (NSString *)yj_description:(NSInteger)depth\n{\n    NSMutableString *logStr = [NSMutableString string];\n    [logStr appendFormat:@\"(\\n\"];\n    NSInteger arrayLength = self.count;\n    [self enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        for (NSInteger i = 1; i <= depth; ++i) {\n            [logStr appendFormat:@\"\\t\"];\n        }\n        if ([obj isKindOfClass:[NSArray class]]) {\n            if (idx != arrayLength - 1) {\n                [logStr appendFormat:@\"%@,\\n\", obj];\n            } else {\n                [logStr appendFormat:@\"%@\\n\", obj];"
        },
        {
            "comment": "Code is determining the type of object and formatting it accordingly in a log string, with indentation based on depth. It checks if the object is an array, dictionary, set or other type, then appends the object to the log string depending on its position in the array and adds the appropriate indentation.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Demo/Foundation+Log.m\":41-79",
            "content": "            }\n            arrayTabCount = depth;\n        } else if ([obj isKindOfClass:[NSDictionary class]]) {\n            dictionaryTabCount = depth;\n            if (idx != arrayLength - 1) {\n                [logStr appendFormat:@\"%@,\\n\", obj];\n            } else {\n                [logStr appendFormat:@\"%@\\n\", obj];\n            }\n        } else if ([obj isKindOfClass:[NSSet class]]) {\n            setTabCount = depth;\n            if (idx != arrayLength - 1) {\n                [logStr appendFormat:@\"%@,\\n\", obj];\n            } else {\n                [logStr appendFormat:@\"%@\\n\", obj];\n            }\n        } else {\n            if (idx != arrayLength - 1) {\n                [logStr appendFormat:@\"%@,\\n\", obj];\n            } else {\n                [logStr appendFormat:@\"%@\\n\", obj];\n            }\n        }\n    }];\n    for (NSInteger i = 1; i < depth; ++i) {\n        [logStr appendFormat:@\"\\t\"];\n    }\n    [logStr appendFormat:@\")\"];\n    return logStr;\n}\n@end;\n@implementation NSDictionary(Log)\n- (NSString *)descriptionWithLocale:(id)locale"
        },
        {
            "comment": "This code snippet is defining a method that creates a string representation of an object with nested dictionary, array or set values. The method adds indentation to the printed lines based on the depth of the nested objects and checks the class type of each object before appending to the log string.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Demo/Foundation+Log.m\":80-110",
            "content": "{\n    NSString *logStr = [self yj_description:++dictionaryTabCount];\n    dictionaryTabCount = 0;\n    return logStr;\n}\n- (NSString *)yj_description:(NSInteger)depth\n{\n    NSMutableString *logStr = [NSMutableString string];\n    [logStr appendFormat:@\"{\\n\"];\n    [self enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        for (NSInteger i = 1; i <= depth; ++i) {\n            [logStr appendFormat:@\"\\t\"];\n        }\n        if ([obj isKindOfClass:[NSArray class]]) {\n            arrayTabCount = depth;\n            [logStr appendFormat:@\"%@ =\\t%@;\\n\", key, obj];\n        } else if ([obj isKindOfClass:[NSDictionary class]]) {\n            [logStr appendFormat:@\"%@ =\\t%@;\\n\", key, obj];\n            dictionaryTabCount = depth;\n        } else if ([obj isKindOfClass:[NSSet class]]) {\n            setTabCount = depth;\n            [logStr appendFormat:@\"%@ =\\t%@;\\n\", key, obj];\n        } else {\n            [logStr appendFormat:@\"%@ = %@;\\n\", key, obj];\n        }\n    }];\n    for (NSInteger i = 1; i < depth; ++i) {"
        },
        {
            "comment": "This code appears to implement custom logging functionality for NSSet objects. It generates a formatted string representation of the set contents, with nested arrays and dictionaries indented accordingly. The yj_description method handles this, taking a depth parameter to control indentation levels. This implementation also tracks array and dictionary tab counts separately.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Demo/Foundation+Log.m\":111-151",
            "content": "        [logStr appendFormat:@\"\\t\"];\n    }\n    [logStr appendFormat:@\"}\"];\n    return logStr;\n}\n@end\n@implementation NSSet(Log)\n- (NSString *)descriptionWithLocale:(id)locale\n{\n    NSString *logStr = [self yj_description:++setTabCount];\n    setTabCount = 0;\n    return logStr;\n}\n- (NSString *)yj_description:(NSInteger)depth\n{\n    NSMutableString *logStr = [NSMutableString string];\n    [logStr appendFormat:@\"{(\\n\"];\n    NSInteger setLength = self.count;\n    __block NSInteger idx = 0;\n    [self enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) {\n        for (NSInteger i = 1; i <= depth; ++i) {\n            [logStr appendFormat:@\"\\t\"];\n        }\n        if ([obj isKindOfClass:[NSArray class]]) {\n            arrayTabCount = depth;\n            if (idx != setLength - 1) {\n                [logStr appendFormat:@\"%@,\\n\", obj];\n            } else {\n                [logStr appendFormat:@\"%@\\n\", obj];\n            }\n        } else if ([obj isKindOfClass:[NSDictionary class]]) {\n            dictionaryTabCount = depth;"
        },
        {
            "comment": "This code adds formatting to a log string based on the object type and depth. It appends commas for non-last items, handles NSDictionary, NSArray, NSSet, and other types, and formats indentation. The function returns the final log string.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Demo/Foundation+Log.m\":152-184",
            "content": "            if (idx != setLength - 1) {\n                [logStr appendFormat:@\"%@,\\n\", obj];\n            } else {\n                [logStr appendFormat:@\"%@\\n\", obj];\n            }\n        } else if ([obj isKindOfClass:[NSSet class]]) {\n            if (idx != setLength - 1) {\n                [logStr appendFormat:@\"%@,\\n\", obj];\n            } else {\n                [logStr appendFormat:@\"%@\\n\", obj];\n            }\n            setTabCount = depth;\n        } else {\n            if (idx != setLength - 1) {\n                [logStr appendFormat:@\"%@,\\n\", obj];\n            } else {\n                [logStr appendFormat:@\"%@\\n\", obj];\n            }\n        }\n        ++idx;\n    }];\n    for (NSInteger i = 1; i < depth; ++i) {\n        [logStr appendFormat:@\"\\t\"];\n    }\n    [logStr appendFormat:@\")}\"];\n    return logStr;\n}\n@end\n#endif"
        }
    ]
}