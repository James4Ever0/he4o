{
    "summary": "The TOUtils class offers equality checking and retrieval for demands, tasks, and sub-models in the SMG_NothingIsAll project. It includes AIKVPointer type checks, HNGL node detection, stability score computation, effective rating scores, object stability decay, \"ActYes\" status verification, array merging, and strength value updates.",
    "details": [
        {
            "comment": "The code is a part of the SMG_NothingIsAll project's TOUtils class implementation. It contains several methods for checking equality between two AIKVPointer objects. The methods first check if the objects are mv (matching variable) types, and then compare their algorithms types. If they are not mv types, it simply compares if they are equal at the current level.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":0-39",
            "content": "//\n//  TOUtils.m\n//  SMG_NothingIsAll\n//\n//  Created by jia on 2020/4/2.\n//  Copyright \u00a9 2020\u5e74 XiaoGang. All rights reserved.\n//\n#import \"TOUtils.h\"\n@implementation TOUtils\n+(BOOL) mIsC:(AIKVPointer*)m c:(AIKVPointer*)c layerDiff:(int)layerDiff{\n    if (layerDiff == 0) return [self mIsC_0:m c:c];\n    if (layerDiff == 1) return [self mIsC_1:m c:c];\n    if (layerDiff == 2) return [self mIsC_2:m c:c];\n    return false;\n}\n/**\n *  MARK:--------------------mIsC--------------------\n *  @version\n *      2023.03.11: \u517c\u5bb9mv\u7684\u5224\u65ad (\u53c2\u800328171-todo8);\n *      2023.11.18: mv\u65f6\u4e5f\u5224\u65ad\u62bd\u8c61\u5173\u8054,\u800c\u4e0d\u662f\u76f4\u63a5\u8fd4\u56defalse (\u4fee\u590d\u5224\u65adM1{\u2191\u997f-16}\u548cA13(\u997f16,7)\u7684\u62bd\u5177\u8c61\u5173\u7cfb\u603b\u5931\u8d25);\n */\n+(BOOL) mIsC_0:(AIKVPointer*)m c:(AIKVPointer*)c{\n    if (m && c) {\n        //0. \u5224\u65admv\u7684\u76f8\u7b49;\n        //if (PitIsMv(m) && PitIsMv(c)) return [m.algsType isEqualToString:c.algsType];\n        //1. \u5224\u65ad\u672c\u7ea7\u76f8\u7b49;\n        BOOL equ0 = [m isEqual:c];\n        if (equ0) return true;\n    }\n    return false;\n}\n+(BOOL) mIsC_1:(AIKVPointer*)m c:(AIKVPointer*)c{\n    if (m && c) {\n        //1. \u5224\u65ad\u672c\u7ea7\u76f8\u7b49;\n        if ([self mIsC_0:m c:c]) return true;"
        },
        {
            "comment": "These code snippets define two methods, `mIsC_2` and `mIsC_1`, that check if a pointer `m` is connected to another pointer `c`. The methods use different approaches for 0-1 level and 2-level abstractions. They first convert the pointers to their corresponding abstract representations and then compare them, returning true if they are connected and false otherwise.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":41-71",
            "content": "        //1. \u5728mIsC0\u5224\u65admv\u4e0d\u76f8\u7b49\u65f6,\u8fd8\u6709mv\u7c7b\u578b\u76f4\u63a5\u8fd4\u56defalse;\n        //if (PitIsMv(m) || PitIsMv(c)) return false;\n        //2. \u5224\u65ad\u4e00\u7ea7\u62bd\u8c61;\n        NSArray *mAbs = [SMGUtils convertPointersFromPorts:[AINetUtils absPorts_All:[SMGUtils searchNode:m]]];\n        BOOL equ1 = [mAbs containsObject:c];\n        if (equ1) return true;\n    }\n    return false;\n}\n+(BOOL) mIsC_2:(AIKVPointer*)m c:(AIKVPointer*)c{\n    if (m && c) {\n        //1. \u5224\u65ad0-1\u7ea7\u62bd\u8c61;\n        if ([self mIsC_1:m c:c]) return true;\n        //1. \u5728mIsC0\u5224\u65admv\u4e0d\u76f8\u7b49\u65f6,\u8fd8\u6709mv\u7c7b\u578b\u76f4\u63a5\u8fd4\u56defalse;\n        //if (PitIsMv(m) || PitIsMv(c)) return false;\n        //2. \u5224\u65ad\u4e8c\u7ea7\u62bd\u8c61;\n        NSArray *mAbs = [SMGUtils convertPointersFromPorts:[AINetUtils absPorts_All:[SMGUtils searchNode:m]]];\n        NSArray *cCon = [SMGUtils convertPointersFromPorts:[AINetUtils conPorts_All:[SMGUtils searchNode:c]]];\n        BOOL equ2 = [SMGUtils filterArrA:mAbs arrB:cCon].count > 0;\n        if (equ2) return true;\n    }\n    return false;\n}\n+(BOOL) mIsC_1:(NSArray*)ms cs:(NSArray*)cs{\n    ms = ARRTOOK(ms);\n    cs = ARRTOOK(cs);\n    for (AIKVPointer *c in cs) {"
        },
        {
            "comment": "The code checks if the arrays of abstracts for two given objects have any common elements, and returns true if there is at least one match. The code is part of a larger system that likely uses these methods to determine relationships between various objects in its domain.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":72-97",
            "content": "        for (AIKVPointer *m in ms) {\n            if ([TOUtils mIsC_1:m c:c]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n *  MARK:--------------------\u5224\u65admc\u6709\u5171\u540c\u62bd\u8c61--------------------\n */\n+(BOOL) mcIsBro:(AIKVPointer*)m c:(AIKVPointer*)c {\n    NSMutableArray *mAbs_ps = [[NSMutableArray alloc] initWithArray:Ports2Pits([AINetUtils absPorts_All:[SMGUtils searchNode:m]])];\n    [mAbs_ps addObject:m];\n    NSMutableArray *cAbs_ps = [[NSMutableArray alloc] initWithArray:Ports2Pits([AINetUtils absPorts_All:[SMGUtils searchNode:c]])];\n    [cAbs_ps addObject:c];\n    return [SMGUtils filterSingleFromArr:mAbs_ps checkValid:^BOOL(AIKVPointer *item) {\n        return [cAbs_ps containsObject:item];\n    }];\n}\n+(BOOL) mcIsBro:(NSArray*)matchAlg_ps cansetA:(AIKVPointer*)cansetA_p {\n    //\u7528\u5171\u540c\u62bd\u8c61\u5224\u65adcansetA\u7684\u5339\u914d: \u5224\u65ad\u65b0\u8f93\u5165\u7684matchAlgs\u548ccansetA\u7684\u62bd\u8c61\u662f\u5426\u6709\u5339\u914d;\n    AIAlgNodeBase *cansetAlg = [SMGUtils searchNode:cansetA_p];\n    NSMutableArray *cansetAbses = [[NSMutableArray alloc] initWithArray:Ports2Pits([AINetUtils absPorts_All:cansetAlg])];"
        },
        {
            "comment": "This code defines two methods in the TOUtils class. The first method, `indexOfAbsItem:atConContent:layerDiff:startIndex:endIndex:`, searches for an abstract item (`absItem`) within a given content array (`conContent`). It takes into account layers and indexes, returning the index of the found item. The second method, `mIsC:c:`, checks if two AIKVPointer objects are equal based on their value and layer difference. The code also includes filtering and error handling.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":98-119",
            "content": "    [cansetAbses addObject:cansetA_p];\n    return ARRISOK([SMGUtils filterArrA:matchAlg_ps arrB:cansetAbses]);\n}\n/**\n *  MARK:--------------------\u5224\u65adindexOf (\u652f\u6301\u672c\u7ea7+\u4e00\u7ea7\u62bd\u8c61)--------------------\n *  @bug 2020.06.12 : TOR.R-\u4e2dfirstAt_Plus\u53d6\u503c\u4e3a-1,\u7ecf\u67e5\u56e0\u4e3amIsC\u65b9\u6cd5\u53d6absPorts_Normal,\u5bf9plus/sub\u4e0d\u652f\u6301\u5bfc\u81f4,\u6539\u540e\u597d\u4e86;\n *  @version\n *      2020.09.10: \u652f\u6301layerDiff\u548cstartIndex;\n *\n */\n+(NSInteger) indexOfAbsItem:(AIKVPointer*)absItem atConContent:(NSArray*)conContent{\n    return [self indexOfAbsItem:absItem atConContent:conContent layerDiff:1 startIndex:0 endIndex:NSUIntegerMax];\n}\n//absItem\u662fcontent\u4e2d\u7684\u62bd\u8c61\u4e00\u5458,\u8fd4\u56deindex;\n+(NSInteger) indexOfAbsItem:(AIKVPointer*)absItem atConContent:(NSArray*)conContent layerDiff:(int)layerDiff startIndex:(NSInteger)startIndex endIndex:(NSInteger)endIndex{\n    conContent = ARRTOOK(conContent);\n    endIndex = MIN(endIndex, conContent.count - 1);\n    for (NSInteger i = startIndex; i <= endIndex; i++) {\n        AIKVPointer *item_p = ARR_INDEX(conContent, i);\n        if ([TOUtils mIsC:item_p c:absItem layerDiff:layerDiff]) {"
        },
        {
            "comment": "This code defines two methods, both searching for a specific object (conItem or item) within an array (content) and returning its index if found. The search considers the layerDiff parameter, which seems to represent a difference in layers between the objects being compared. The first method returns -1 if the object is not found, while the second method continues searching if the first method returns -1.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":120-143",
            "content": "            return i;\n        }\n    }\n    return -1;\n}\n//conItem\u662fcontent\u4e2d\u7684\u5177\u8c61\u4e00\u5458,\u8fd4\u56deindex;\n+(NSInteger) indexOfConItem:(AIKVPointer*)conItem atAbsContent:(NSArray*)content layerDiff:(int)layerDiff startIndex:(NSInteger)startIndex endIndex:(NSInteger)endIndex{\n    content = ARRTOOK(content);\n    endIndex = MIN(endIndex, content.count - 1);\n    for (NSInteger i = startIndex; i <= endIndex; i++) {\n        AIKVPointer *item_p = ARR_INDEX(content, i);\n        if ([TOUtils mIsC:conItem c:item_p layerDiff:layerDiff]) {\n            return i;\n        }\n    }\n    return -1;\n}\n//conItem\u662fcontent\u4e2d\u7684\u5177\u8c61\u6216\u62bd\u8c61\u4e00\u5458,\u8fd4\u56deindex;\n+(NSInteger) indexOfConOrAbsItem:(AIKVPointer*)item atContent:(NSArray*)content layerDiff:(int)layerDiff startIndex:(NSInteger)startIndex endIndex:(NSInteger)endIndex{\n    NSInteger findIndex = [TOUtils indexOfAbsItem:item atConContent:content layerDiff:layerDiff startIndex:startIndex endIndex:endIndex];\n    if (findIndex == -1) {\n        findIndex = [TOUtils indexOfConItem:item atAbsContent:content layerDiff:layerDiff startIndex:startIndex endIndex:endIndex];"
        },
        {
            "comment": "This code contains several methods: `getBasePFoWithSubOutModel`, `getRootDemandModelWithSubOutModel`, and `getBaseDemands_AllDeep`. The first method searches for the base Parent-Fo (pFo) of a given sub-model, returning nil if no pFo is found. The second method retrieves the root demand model from a given sub-out-model by extracting all demands in its path and selecting the first one in reverse order. The third method gets all base demands for a given sub-out-model recursively.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":144-179",
            "content": "    }\n    return findIndex;\n}\n//MARK:===============================================================\n//MARK:                     < \u4eceTO\u77ed\u65f6\u8bb0\u5fc6\u53d6demand >\n//MARK:===============================================================\n//\u83b7\u53d6subOutModel\u6240\u5728\u7684pFo\n+(AIMatchFoModel*) getBasePFoWithSubOutModel:(TOModelBase*)subOutModel {\n    //1. \u6700\u7ec8\u6ca1\u627e\u7740,\u8fd4\u56denil;\n    if (!subOutModel) return nil;\n    //2. \u5f53\u524d\u662ffo\u4e14\u6709\u6307\u5411pFo\u65f6: \u627e\u5230\u4e86,\u8fd4\u56de;\n    if (ISOK(subOutModel, TOFoModel.class)) {\n        TOFoModel *foModel = (TOFoModel*)subOutModel;\n        if (ISOK(foModel.basePFoOrTargetFoModel, AIMatchFoModel.class)) {\n            return foModel.basePFoOrTargetFoModel;\n        }\n    }\n    //3. \u5f53\u524d\u6ca1\u627e\u5230pFo,\u5219\u7ee7\u7eed\u987a\u7740base\u627e\u4e0a\u53bb;\n    return [self getBasePFoWithSubOutModel:subOutModel.baseOrGroup];\n}\n/**\n *  MARK:--------------------\u83b7\u53d6subOutModel\u7684demand--------------------\n */\n+(DemandModel*) getRootDemandModelWithSubOutModel:(TOModelBase*)subOutModel{\n    NSMutableArray *demands = [self getBaseDemands_AllDeep:subOutModel];\n    return ARR_INDEX_REVERSE(demands, 0);\n}\n/**\n *  MARK:--------------------\u5411\u7740\u67d0\u65b9\u5411\u53d6\u6240\u6709demands--------------------"
        },
        {
            "comment": "This code retrieves base and sub tasks, and counts the number of base demands in each category (demands and reason demands) from a given model. It also provides methods to filter and retrieve related reason demands based on the provided model. The code is part of a larger project focused on task management and organization.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":180-208",
            "content": " *  @version\n *      2021.06.01: \u56e0\u4e3aR\u5b50\u4efb\u52a1\u65f6baseOrGroup\u4e3a\u7a7a,\u5bfc\u81f4\u94fe\u6761\u4e2d\u65ad\u83b7\u53d6\u4e0d\u5168\u7684BUG\u4fee\u590d (\u53c2\u800323094);\n *      2021.06.01: \u652f\u6301getSubDemands_AllDeep (\u5b50\u65b9\u5411);\n *  @result \u542b\u5b50\u4efb\u52a1\u548croot\u4efb\u52a1 notnull;\n *  @rank : base\u5728\u540e,sub\u5728\u524d;\n */\n+(NSMutableArray*) getBaseDemands_AllDeep:(TOModelBase*)subModel{\n    return [SMGUtils filterArr:[self getBaseOutModels_AllDeep:subModel] checkValid:^BOOL(id item) {\n        return ISOK(item, DemandModel.class);\n    }];\n}\n+(NSInteger) getBaseDemandsDeepCount:(TOModelBase*)subModel{\n    return [self getBaseDemands_AllDeep:subModel].count;\n}\n+(NSMutableArray*) getBaseRDemands_AllDeep:(TOModelBase*)subModel{\n    return [SMGUtils filterArr:[self getBaseOutModels_AllDeep:subModel] checkValid:^BOOL(id item) {\n        return ISOK(item, ReasonDemandModel.class);\n    }];\n}\n/**\n *  MARK:--------------------\u83b7\u53d6rDemand\u7684\u6765\u6e90\u540c\u4f34--------------------\n *  @version\n *      2022.03.23: \u521d\u7248 (\u53c2\u800325184-\u65b9\u68482-\u5206\u6790);\n *  @result notnull\n */\n//+(NSArray*) getSeemFromIdenRDemands:(ReasonDemandModel*)rDemand{\n//    //1. \u6570\u636e\u51c6\u5907;\n//    NSString *fromIden = STRTOOK(rDemand.fromIden);"
        },
        {
            "comment": "This code retrieves all `DemandModel` objects from the `outModelManager` and iterates through them, collecting their child `subOutModels` that match a specific `fromIden`. It then filters the collected `subOutModels` based on a custom condition. Finally, it filters the entire result list using another custom condition before returning the result.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":209-230",
            "content": "//    NSMutableArray *result = [[NSMutableArray alloc] init];\n//\n//    //2. \u5206\u522b\u4eceroot\u51fa\u53d1,\u6536\u96c6\u540cfromIden\u7684RDemands;\n//    for (DemandModel *item in theTC.outModelManager.getAllDemand) {\n//        NSArray *subs = [self getSubOutModels_AllDeep:item validStatus:nil cutStopStatus:nil];\n//        NSArray *validSubs = [SMGUtils filterArr:subs checkValid:^BOOL(ReasonDemandModel *sub) {\n//            return ISOK(sub, ReasonDemandModel.class) && [fromIden isEqualToString:sub.fromIden];\n//        }];\n//        [result addObjectsFromArray:validSubs];\n//    }\n//result = [SMGUtils filterArr:result checkValid:^BOOL(ReasonDemandModel *item) {\n//    AIFoNodeBase *itemFo = [SMGUtils searchNode:item.mModel.matchFo];\n//    AIFoNodeBase *demandFo = [SMGUtils searchNode:demand.mModel.matchFo];\n//    return [demandFo.cmvNode_p.identifier isEqualToString:itemFo.cmvNode_p.identifier];\n//}];\n//    return result;\n//}\n//MARK:===============================================================\n//MARK:                     < \u4eceTO\u77ed\u65f6\u8bb0\u5fc6\u53d6outModel >\n//MARK:==============================================================="
        },
        {
            "comment": "This method retrieves all sub models of the given `outModel` with a specific status, including their descendants. It takes optional arrays for valid and cut-stop statuses as parameters. It first prepares the data by converting the status arrays to immutable ones and initializes an empty array called 'result'. If no outModel is provided, it returns the result immediately. Then, it checks if the given model's status matches any of the valid statuses or if there are no valid statuses specified. If so, it adds the current model to the result array. Finally, if the current model's status is not one of the cut-stop statuses, it recursively calls itself for all sub-models and adds their results to the 'result' array.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":231-254",
            "content": "+(NSArray*) getSubOutModels_AllDeep:(TOModelBase*)outModel validStatus:(NSArray*)validStatus{\n    return [self getSubOutModels_AllDeep:outModel validStatus:validStatus cutStopStatus:@[@(TOModelStatus_Finish)]];\n}\n+(NSArray*) getSubOutModels_AllDeep:(TOModelBase*)outModel validStatus:(NSArray*)validStatus cutStopStatus:(NSArray*)cutStopStatus{\n    //1. \u6570\u636e\u51c6\u5907\n    validStatus = ARRTOOK(validStatus);\n    cutStopStatus = ARRTOOK(cutStopStatus);\n    NSMutableArray *result = [[NSMutableArray alloc] init];\n    if (!outModel) return result;\n    //2. \u6536\u96c6\u5f53\u524d (\u5f53valid\u4e3a\u7a7a\u65f6,\u5168\u6536\u96c6);\n    if (!ARRISOK(validStatus) || [validStatus containsObject:@(outModel.status)]) {\n        [result addObject:outModel];\n    }\n    //3. Finish\u8d1f\u8d23\u622a\u505c\u9012\u5f52;\n    if (![cutStopStatus containsObject:@(outModel.status)]) {\n        //3. \u627e\u51fa\u5b50\u96c6\n        NSMutableArray *subs = [self getSubOutModels:outModel];\n        //4. \u9012\u5f52\u6536\u96c6\u5b50\u96c6;\n        for (TOModelBase *sub in subs) {\n            [result addObjectsFromArray:[self getSubOutModels_AllDeep:sub validStatus:validStatus cutStopStatus:cutStopStatus]];"
        },
        {
            "comment": "This code gets a parent model and returns a mutable array of its submodels. It checks if the parent model conforms to three protocols: ITryActionFoDelegate, ISubModelsDelegate, and ISubDemandDelegate. If it does, it adds the corresponding models to the result array.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":255-282",
            "content": "        }\n    }\n    return result;\n}\n/**\n *  MARK:--------------------\u83b7\u53d6\u5b50models--------------------\n *  @version\n *      2021.06.03: \u5c06\u5b9e\u73b0\u63a5\u53e3\u5224\u65ad,\u6539\u4e3a\u4f7f\u7528conformsToProtocol,\u800c\u975e\u5224\u65ad\u7c7b\u540d (\u56e0\u4e3a\u7c7b\u540d\u65b9\u5f0f\u6709\u65b0\u7684\u7c7b\u518d\u5b9e\u73b0\u540e,\u6613\u51fabug);\n *  @result notnull\n */\n+(NSMutableArray*) getSubOutModels:(TOModelBase*)outModel {\n    //1. \u6570\u636e\u51c6\u5907\n    NSMutableArray *result = [[NSMutableArray alloc] init];\n    if (!outModel) return result;\n    //2. \u627e\u51fa\u5b50\u96c6 (Finish\u8d1f\u8d23\u622a\u505c\u9012\u5f52);\n    if ([outModel conformsToProtocol:@protocol(ITryActionFoDelegate)]) {\n        id<ITryActionFoDelegate> tryActionObj = (id<ITryActionFoDelegate>)outModel;\n        [result addObjectsFromArray:tryActionObj.actionFoModels];\n    }\n    if ([outModel conformsToProtocol:@protocol(ISubModelsDelegate)]) {\n        id<ISubModelsDelegate> subModelsObj = (id<ISubModelsDelegate>)outModel;\n        [result addObjectsFromArray:subModelsObj.subModels];\n    }\n    if ([outModel conformsToProtocol:@protocol(ISubDemandDelegate)]) {\n        id<ISubDemandDelegate> subDemandsObj = (id<ISubDemandDelegate>)outModel;\n        [result addObjectsFromArray:subDemandsObj.subDemands];"
        },
        {
            "comment": "This method is used to retrieve a list of base models from a given model sub-tree. The code first checks if the sub-model is valid and then iterates through the sub-tree, adding each base or group model to a result array. Finally, it returns this array containing all base models found in the sub-tree.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":283-317",
            "content": "    }\n    return result;\n}\n+(NSMutableArray*) getBaseOutModels_AllDeep:(TOModelBase*)subModel{\n    //1. \u6570\u636e\u51c6\u5907;\n    NSMutableArray *result = [[NSMutableArray alloc] init];\n    if (!subModel) return result;\n    //2. \u5411base\u53d6;\n    TOModelBase *checkModel = subModel;\n    while (checkModel) {\n        [result addObject:checkModel];\n        checkModel = checkModel.baseOrGroup;\n    }\n    return result;\n}\n//MARK:===============================================================\n//MARK:                     < convert >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u5c06TOModels\u8f6c\u4e3aPointers--------------------\n *  @result notnull\n */\n+(NSMutableArray*) convertPointersFromTOModels:(NSArray*)toModels{\n    //1. \u6536\u96c6\u8fd4\u56de (\u4e0d\u6536\u96c6content_p\u4e3a\u7a7a\u7684\u90e8\u5206,\u5982:TOValueModel\u7684\u76ee\u6807pValue\u6709\u65f6\u4e3a\u7a7a);\n    return [SMGUtils convertArr:toModels convertBlock:^id(TOModelBase *obj) {\n        return obj.content_p;\n    }];\n}\n//R\u65f6\u8fd4\u56depFo.matchFo,H\u65f6\u8fd4\u56detargetFo;\n+(AIKVPointer*) convertBaseFoFromBasePFoOrTargetFoModel:(id)basePFoOrTargetFoModel {"
        },
        {
            "comment": "This code checks the type of a given AIKVPointer and returns its match or content value. It also contains utility functions to check if the pointer is of type H, N, G, L, S or P. These functions are used to determine if a node is an HNGL node, which could be used in decision making or further processing.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":318-350",
            "content": "    if (ISOK(basePFoOrTargetFoModel, AIMatchFoModel.class)) {\n        AIMatchFoModel *pFo = (AIMatchFoModel*)basePFoOrTargetFoModel;\n        return pFo.matchFo;\n    } else if(ISOK(basePFoOrTargetFoModel, TOFoModel.class)){\n        TOFoModel *targetFo = (TOFoModel*)basePFoOrTargetFoModel;\n        return targetFo.content_p;\n    }\n    return nil;\n}\n/**\n *  MARK:--------------------\u662f\u5426HNGL\u8282\u70b9--------------------\n *  @version\n *      2020.12.16: \u589e\u52a0toAlgModel\u5224\u65ad\u7684\u91cd\u8f7d (\u56e0\u4e3a21115\u7684\u6539\u52a8,hngl\u5e76\u4e0d\u76f4\u63a5\u7531alg\u5224\u65ad,\u800c\u662f\u7531fo\u6765\u5224\u65ad);\n *  @bug\n *      2020.12.24: isL\u5199\u6210\u4e86isN,\u5bfc\u81f4L\u8282\u70b9\u65e0\u6cd5\u5224\u5b9a\u4e3aHNGL,\u4e5f\u5bfc\u81f4\u65e0\u6cd5ActYes\u5e76\u89e6\u53d1\u53cd\u7701\u7c7b\u6bd4;\n */\n+(BOOL) isHNGL:(AIKVPointer*)p{\n    return [self isH:p] || [self isN:p] || [self isG:p] || [self isL:p];\n}\n+(BOOL) isHNGLSP:(AIKVPointer*)p{\n    return [self isH:p] || [self isN:p] || [self isG:p] || [self isL:p] || [self isS:p] || [self isP:p];\n}\n+(BOOL) isH:(AIKVPointer*)p{\n    return p && p.type == ATHav;\n}\n+(BOOL) isN:(AIKVPointer*)p{\n    return p && p.type == ATNone;\n}\n+(BOOL) isG:(AIKVPointer*)p{\n    return p && p.type == ATGreater;\n}\n+(BOOL) isL:(AIKVPointer*)p{"
        },
        {
            "comment": "This code contains several methods for checking the type of AIKVPointer, and a method for calculating the sum of deltaTimes in a specified range of AIFoNodeBase. The getSumDeltaTime method takes a start index and end index as parameters to calculate the sum of deltaTimes within that range.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":351-382",
            "content": "    return p && p.type == ATLess;\n}\n+(BOOL) isS:(AIKVPointer*)p{\n    return p && p.type == ATSub;\n}\n+(BOOL) isP:(AIKVPointer*)p{\n    return p && p.type == ATPlus;\n}\n/**\n *  MARK:--------------------\u6c42fo\u7684deltaTime\u4e4b\u548c--------------------\n */\n//\u4ececutIndex\u53d6\u5230mvDeltaTime;\n+(double) getSumDeltaTime2Mv:(AIFoNodeBase*)fo cutIndex:(NSInteger)cutIndex{\n    return [self getSumDeltaTime:fo startIndex:cutIndex endIndex:fo.count];\n}\n/**\n *  MARK:--------------------\u83b7\u53d6\u6307\u5b9a\u83b7\u53d6\u7684deltaTime\u4e4b\u548c--------------------\n *  _param startIndex   : \u4e0b\u6807(\u4e0d\u542b);\n *  _param endIndex     : \u4e0b\u6807(\u542b);\n *  @templete : \u5982[0,1,2,3],\u56e0\u4e0d\u542bs\u548c\u542be,\u53d61\u52303\u4f4d\u65f6,\u5f97\u51fa\u7ed3\u679c\u5e94\u8be5\u662f2+3=5,\u5373range\u5e94\u8be5\u662f(2\u52304),\u6240\u4ee5range=(s+1,e-s);\n *  @bug\n *      2020.09.10: \u539f\u6765\u53d6range(s,e-s)\u4e0d\u5bf9,\u66f4\u6b63\u4e3a:range(s+1,e-s);\n */\n+(double) getSumDeltaTime:(AIFoNodeBase*)fo startIndex:(NSInteger)startIndex endIndex:(NSInteger)endIndex{\n    double result = 0;\n    if (fo) {\n        //1. \u7d2f\u8ba1deltaTimes\u4e2d\u503c;\n        NSArray *valids = ARR_SUB(fo.deltaTimes, startIndex + 1, endIndex - startIndex);\n        for (NSNumber *valid in valids) {\n            result += [valid doubleValue];"
        },
        {
            "comment": "This function calculates the cumulative mvDeltaTime value for a given sequence of objects, returns an NSString representation of TOModelBase by converting its address and content_p value, defines getSumEffectHN to calculate the sum of effectDic's horizontal and numerical values, provides a stable score calculation method that takes in AIFoNodeBase, startSPIndex, and endSPIndex as parameters, and returns CGFloat representing the stability score.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":383-421",
            "content": "        }\n        //2. \u7d2f\u8ba1mvDeltaTime\u503c;\n        if (endIndex >= fo.count) {\n            result += fo.mvDeltaTime;\n        }\n    }\n    return result;\n}\n+(NSString*) toModel2Key:(TOModelBase*)toModel{\n    return STRFORMAT(@\"%p_%@\",toModel,Pit2FStr(toModel.content_p));\n}\n/**\n *  MARK:--------------------effectDic\u7684HN\u6c42\u548c--------------------\n */\n+(NSRange) getSumEffectHN:(NSDictionary*)effectDic{\n    int sumH = 0,sumN = 0;\n    for (NSArray *value in effectDic.allValues) {\n        for (AIEffectStrong *strong in value) {\n            sumH += strong.hStrong;\n            sumN += strong.nStrong;\n        }\n    }\n    return NSMakeRange(sumH, sumN);\n}\n/**\n *  MARK:--------------------\u7a33\u5b9a\u6027\u8bc4\u5206--------------------\n *  @desc \u6839\u636eSP\u8ba1\u7b97\"\u7a33\u5b9a\u6027\"\u5206 (\u7a33\u5b9a\u6027\u6307\u987a,\u5c31\u662f\u80fd\u987a\u5229\u53d1\u751f\u7684\u7387);\n *  @version\n *      2022.05.23: \u521d\u7248 (\u53c2\u800326096-BUG1);\n *      2022.06.02: \u6bcf\u4e00\u5e27\u7684\u7a33\u5b9a\u6027\u9ed8\u8ba4\u4e3a0.5,\u800c\u4e0d\u662f1 (\u53c2\u800326191);\n *  @result 1. \u8d1f\u4ef7\u503c\u65f6\u5e8f\u65f6\u8fd4\u56de\u591a\u574f(0-1);\n *          2. \u6b63\u4ef7\u503c\u65f6\u5e8f\u65f6\u8fd4\u56de\u591a\u597d(0-1);\n *          3. \u65e0\u4ef7\u503c\u65f6\u5e8f\u65f6\u8fd4\u56de\u591a\u987a(0-1);\n */\n+(CGFloat) getStableScore:(AIFoNodeBase*)fo startSPIndex:(NSInteger)startSPIndex endSPIndex:(NSInteger)endSPIndex{"
        },
        {
            "comment": "Checks data integrity and initializes stability score to 1. Calculates spScore for each section from start to end index. If all sp values are 0, sets default score to 0.5. If any sp value is not zero, calculates the steadiness score. Uses the ratio of positive to total sp values and applies it to itemSPScore based on mv type. Finally, adds itemSPScore to totalSPScore.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":422-451",
            "content": "    //1. \u6570\u636e\u68c0\u67e5 & \u7a33\u5b9a\u6027\u9ed8\u8ba4\u4e3a1\u5206 & \u6b63\u8d1fmv\u7684\u516c\u5f0f\u662f\u4e0d\u540c\u7684 (\u53c2\u800325122-\u516c\u5f0f);\n    if (!fo) return 0;\n    CGFloat totalSPScore = 1.0f;\n    BOOL isBadMv = [ThinkingUtils havDemand:fo.cmvNode_p];\n    //2. \u4ecestart\u5230end\u5404\u8ba1\u7b97spScore;\n    for (NSInteger i = startSPIndex; i <= endSPIndex; i++) {\n        AISPStrong *spStrong = [fo.spDic objectForKey:@(i)];\n        //3. \u5f53sp\u7ecf\u5386\u90fd\u4e3a0\u6761\u65f6 (\u6b63mv\u65f6,\u8868\u793a\u591a\u597d\u8bc4\u5206 | \u8d1fmv\u65f6,\u8868\u793a\u591a\u574f\u8bc4\u5206) \u9ed8\u8ba4\u8bc4\u5206\u90fd\u4e3a0.5;\n        CGFloat itemSPScore = 0.5f;\n        //4. SP\u6709\u6548\u4e14\u5176\u4e2d\u4e4b\u4e00\u4e0d\u4e3a0\u65f6,\u8ba1\u7b97\u7a33\u5b9a\u6027\u8bc4\u5206;\n        if (spStrong && spStrong.pStrong + spStrong.sStrong > 0) {\n            //4. \u53d6\"\u591a\u597d\"\u7a0b\u5ea6;\n            CGFloat pRate = spStrong.pStrong / (float)(spStrong.sStrong + spStrong.pStrong);\n            //5.1 \u5728\u611f\u6027\u7684\u8d1fmv\u65f6,itemSPScore = 1 - pRate (\u53c2\u800325122-\u8d1f\u516c\u5f0f);\n            if (i == fo.count && isBadMv) {\n                itemSPScore = 1 - pRate;\n            }else{\n                //5.2 \u5728\u7406\u6027\u8bc4\u5206\u4e2d,pStrong\u8868\u793a\u987a\u5229\u7a0b\u5ea6,\u4e0emv\u6b63\u8d1f\u6210\u6b63\u6bd4;\n                //5.3 \u5728\u611f\u6027\u6b63mv\u65f6,pRate\u4e0e\u5b83\u7684\u7a33\u5b9a\u6027\u8bc4\u5206\u4e00\u81f4;\n                itemSPScore = pRate;\n            }\n        }\n        //6. \u5c06itemSPScore\u8ba1\u5165\u7efc\u5408\u8bc4\u5206 (\u53c2\u800325114 & 25122-\u516c\u5f0f);"
        },
        {
            "comment": "Calculates the overall stability score based on the given start and end indices for the stability parameters, considers negative motion vectors, and returns a value between 0 and 1 indicating how good or bad the stability is.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":452-481",
            "content": "        totalSPScore *= itemSPScore;\n    }\n    //9. \u8fd4\u56deSP\u8bc4\u5206 (\u591a\u574f\u6216\u591a\u597d);\n    return totalSPScore;\n}\n/**\n *  MARK:--------------------SP\u597d\u574f\u8bc4\u5206--------------------\n *  @desc \u6839\u636e\u7efc\u5408\u7a33\u5b9a\u6027\u8ba1\u7b97\"\u591a\u597d\"\u8bc4\u5206 (\u53c2\u800325114 & 25122-\u8d1f\u516c\u5f0f);\n *  @version\n *      2022.02.20: \u6539\u4e3a\u7efc\u5408\u8bc4\u5206,\u66ff\u4ee3\u6389RSResultModelBase;\n *      2022.02.22: \u4fee\u590d\u660e\u660eS\u6709\u503c,P\u4e3a0,\u4f46\u7efc\u8bc4\u4e3a1\u5206\u7684\u95ee\u9898 (||\u5199\u6210\u4e86&&\u5bfc\u81f4\u7684);\n *      2022.02.24: \u652f\u6301\u8d1fmv\u65f6\u5e8f\u7684\u7a33\u5b9a\u6027\u8bc4\u5206\u516c\u5f0f (\u53c2\u800325122-\u8d1f\u516c\u5f0f);\n *      2022.02.24: \u4fee\u590d\u56e0\u4ee3\u7801\u903b\u8f91\u9519\u8bef,\u5bfc\u81f4\u8d1fmv\u5728\u5168\u987a\u72b6\u6001\u4e0b,\u8bc4\u4e3a1\u5206\u7684BUG (\u4fee\u590d: \u660e\u786eitemSPScore\u7684\u5b9a\u4e49,\u6574\u7406\u4ee3\u7801\u540eok);\n *      2022.05.02: \u4fee\u590d\u56e0Int\u503c\u7c7b\u578b,\u5bfc\u81f4\u8fd4\u56deresult\u53ea\u53ef\u80fd\u662f0\u62161\u7684\u95ee\u9898;\n *      2022.05.14: \u5f53SP\u5168\u4e3a0\u65f6,\u9ed8\u8ba4\u8fd4\u56de0.5 (\u53c2\u800326026-BUG2);\n *  @result \u8fd4\u56despScore\u7a33\u5b9a\u6027\u7efc\u5408\u8bc4\u5206: \u8d8a\u63a5\u8fd11\u5206\u8d8a\u597d,\u8d8a\u63a5\u8fd10\u5206\u8d8a\u5dee;\n */\n+(CGFloat) getSPScore:(AIFoNodeBase*)fo startSPIndex:(NSInteger)startSPIndex endSPIndex:(NSInteger)endSPIndex{\n    //1. \u83b7\u53d6\u7a33\u5b9a\u6027\u8bc4\u5206;\n    CGFloat stableScore = [self getStableScore:fo startSPIndex:startSPIndex endSPIndex:endSPIndex];\n    //2. \u8d1fmv\u7684\u516c\u5f0f\u662f: 1-stableScore (\u53c2\u800325122-\u516c\u5f0f&\u8d1f\u516c\u5f0f);\n    BOOL isBadMv = [ThinkingUtils havDemand:fo.cmvNode_p];\n    if (isBadMv) {\n        stableScore = 1 - stableScore;\n    }\n    //3. \u8fd4\u56de\u597d\u574f\u8bc4\u5206;"
        },
        {
            "comment": "This code calculates the effective rating score based on the given demand, effect index, and solution Fo. It returns the stable score calculated in the previous section. The getEffectScore method takes parameters demandFo, effectIndex, and solutionFo to calculate the effective rating score using getEffectScore:getEffectStrong: methods.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":482-508",
            "content": "    return stableScore;\n}\n/**\n *  MARK:--------------------\u6709\u6548\u7387\u8bc4\u5206--------------------\n *  @desc \u8ba1\u7b97\u6709\u6548\u7387\u6027\u8bc4\u5206 (\u53c2\u800326095-8);\n *  @param demandFo     : R\u4efb\u52a1\u65f6\u4f20pFo\u5373\u53ef, H\u4efb\u52a1\u65f6\u4f20hDemand.base.baseFo;\n *  @param effectIndex  : R\u4efb\u52a1\u65f6\u4f20demandFo.count, H\u4efb\u52a1\u65f6\u4f20hDemand.base.baseFo.actionIndex;\n *  @param solutionFo   : \u7528\u4e8e\u68c0\u67e5\u6709\u6548\u7387\u7684solutionFo;\n *  @version\n *      2022.05.22: \u521d\u7248,\u53ef\u8fd4\u56de\u89e3\u51b3\u65b9\u6848\u7684\u6709\u6548\u7387 (\u53c2\u800326095-8);\n */\n+(CGFloat) getEffectScore:(AIFoNodeBase*)demandFo effectIndex:(NSInteger)effectIndex solutionFo:(AIKVPointer*)solutionFo{\n    AIEffectStrong *strong = [self getEffectStrong:demandFo effectIndex:effectIndex solutionFo:solutionFo];\n    return [self getEffectScore:strong];\n}\n+(CGFloat) getEffectScore:(AIEffectStrong*)strong{\n    if (strong) {\n        if (strong.hStrong + strong.nStrong > 0) {\n            return (float)strong.hStrong / (strong.hStrong + strong.nStrong);\n        }else{\n            return 0.0f;\n        }\n    }\n    return 0;\n}\n+(AIEffectStrong*) getEffectStrong:(AIFoNodeBase*)demandFo effectIndex:(NSInteger)effectIndex solutionFo:(AIKVPointer*)solutionFo{"
        },
        {
            "comment": "This code snippet is for retrieving the effect description and handling decay curves to calculate the final value of a given fo. It involves getting an effect strong object, formatting a string with the strong values, and using Newton's cooling function to compute the final value after factoring in competing fos.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":509-532",
            "content": "    return [demandFo getEffectStrong:effectIndex solutionFo:solutionFo];\n}\n+(NSString*) getEffectDesc:(AIFoNodeBase*)demandFo effectIndex:(NSInteger)effectIndex solutionFo:(AIKVPointer*)solutionFo{\n    AIEffectStrong *strong = [self getEffectStrong:demandFo effectIndex:effectIndex solutionFo:solutionFo];\n    return STRFORMAT(@\"%ld/%ld\",strong.hStrong,strong.hStrong + strong.nStrong);\n}\n//MARK:===============================================================\n//MARK:                     < \u8870\u51cf\u66f2\u7ebf >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u83b7\u53d6fo\u8870\u51cf\u540e\u7684\u503c--------------------\n *  @param fo_p         : \u8ba1\u7b97fo\u7684\u8870\u51cf\u540e\u7684\u503c;\n *  @param outOfFo_ps   : fo\u7684\u7ade\u4e89\u8005 (\u5305\u542bfo);\n *  @desc \u4f7f\u7528\u725b\u987f\u51b7\u5374\u51fd\u6570,\u6b65\u9aa4\u8bf4\u660e:\n *      1. \u6839\u636eF\u6307\u9488\u5730\u5740\u6392\u5e8f,\u6bd4\u5982(F1,F3,F5,F7,F9)\n *      2. \u9ed8\u8ba4\u8870\u51cf\u65f6\u95f4\u4e3aF\u603b\u6570,\u53735;\n *      3. \u5f53sp\u5f3a\u5ea6\u90fd\u4e3a1\u65f6,\u6700\u65b0\u7684F9\u4e3a\u70ed\u5ea6\u4e3a1,\u6700\u65e7\u7684F1\u70ed\u5ea6\u4e3aminValue;\n *      4. \u5f53sp\u5f3a\u5ea6>1\u65f6,\u8870\u51cf\u65f6\u957f = \u9ed8\u8ba4\u65f6\u957f5 * \u6839\u53f7sp\u5f3a\u5ea6;\n *  @version\n *      2022.05.24: \u521d\u7248,\u7528\u4e8e\u89e3\u51b3fo\u7684\u8870\u51cf,\u907f\u514d\u65f6\u5e8f\u8bc6\u522b\u65f6,\u660e\u660efo\u5f88\u8001\u4e14SP\u90fd\u662f0,\u5374\u53ef\u4ee5\u6392\u5728\u5f88\u524d\u9762 (\u53c2\u800326104-\u65b9\u6848);\n */\n+(double) getColValue:(AIKVPointer*)fo_p outOfFos:(NSArray*)outOfFo_ps {"
        },
        {
            "comment": "This function calculates the decay value for an object's stability score based on its age and a set of other objects, using exponential decay formula. It first checks if the input object is valid, then sorts the set of objects by their pointerId in descending order, calculates the decay space based on the sum of strong values from all SPStrongs in the Fo node, determines the actual decay range as default range multiplied by strong value, computes the decay factor using logarithm with minValue as base and current index, finally returns the exponential result of decay factor times age.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":533-566",
            "content": "    //0. \u6570\u636e\u68c0\u67e5;\n    if (!fo_p || ![outOfFo_ps containsObject:fo_p]) {\n        return 1.0f;\n    }\n    //1. \u5bf9fos\u6392\u5e8f & \u8ba1\u7b97\u8870\u51cf\u533a (\u4ece1\u5230minValue\u7684\u9ed8\u8ba4\u533a\u95f4: \u5373\u6bcf\u5f3a\u5ea6\u7cfb\u6570\u5355\u4f4d\u53ef\u652f\u6491\u533a\u95f4);\n    outOfFo_ps = [SMGUtils sortBig2Small:outOfFo_ps compareBlock:^double(AIKVPointer *obj) {\n        return obj.pointerId;\n    }];\n    float defaultColSpace = outOfFo_ps.count;\n    //2. \u8ba1\u7b97fo\u7684sp\u5f3a\u5ea6\u7cfb\u6570 (\u603b\u5f3a\u5ea6 + 1,\u7136\u540e\u5f00\u6839\u53f7);\n    AIFoNodeBase *fo = [SMGUtils searchNode:fo_p];\n    int sumSPStrong = 1;\n    for (AISPStrong *item in fo.spDic.allValues) sumSPStrong += (item.sStrong + item.pStrong);\n    float strongXiSu = sqrtf(sumSPStrong);\n    //3. fo\u7684\u5b9e\u9645\u8870\u51cf\u533a\u95f4 (\u9ed8\u8ba4\u533a\u95f4 x \u5f3a\u5ea6\u7cfb\u6570);\n    float colSpace = defaultColSpace * strongXiSu;\n    //4. \u8870\u51cf\u7cfb\u6570 (\u5728colTime\u7ed3\u675f\u540e,\u8870\u51cf\u5230\u6700\u5c0f\u503c);\n    float minValue = 0.1f;\n    double colXiSu = log(minValue) / colSpace;\n    //5. \u53d6\u5f53\u524dfo\u7684age & \u8ba1\u7b97\u725b\u987f\u8870\u51cf\u540e\u7684\u503c;\n    NSInteger foAge = [outOfFo_ps indexOfObject:fo_p];\n    double result = exp(colXiSu * foAge);\n    return result;\n}\n/**\n *  MARK:--------------------\u83b7\u53d6\u8870\u51cf\u540e\u7684\u7a33\u5b9a\u6027--------------------\n */\n+(CGFloat) getColStableScore:(A"
        },
        {
            "comment": "This code calculates the stable score and colSPScore of a given foNodeBase, taking into account outOfFos and SP indices. It also checks if the toModel has any ActYes state at the end branch, considering subDemand and hDemandModel.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":566-585",
            "content": "IFoNodeBase*)fo outOfFos:(NSArray*)outOfFo_ps startSPIndex:(NSInteger)startSPIndex endSPIndex:(NSInteger)endSPIndex {\n    double colValue = [TOUtils getColValue:fo.pointer outOfFos:outOfFo_ps];\n    CGFloat stableScore = [TOUtils getStableScore:fo startSPIndex:startSPIndex endSPIndex:endSPIndex];\n    return colValue * stableScore;\n}\n/**\n *  MARK:--------------------\u83b7\u53d6\u8870\u51cf\u540e\u7684SP\u597d\u574f\u8bc4\u5206--------------------\n */\n+(CGFloat) getColSPScore:(AIFoNodeBase*)fo outOfFos:(NSArray*)outOfFo_ps startSPIndex:(NSInteger)startSPIndex endSPIndex:(NSInteger)endSPIndex{\n    CGFloat stableScore = [self getColStableScore:fo outOfFos:outOfFo_ps startSPIndex:startSPIndex endSPIndex:endSPIndex];\n    return [ThinkingUtils havDemand:fo.cmvNode_p] ? 1 - stableScore : stableScore;\n}\n/**\n *  MARK:--------------------\u68c0\u67e5\u67d0toModel\u7684\u672b\u679d\u6709\u6ca1\u6709ActYes\u72b6\u6001--------------------\n *  @desc \u56e0\u4e3aactYes\u5411\u4e0a\u4f20\u67d3,\u4e0d\u5411\u4e0b,\u6240\u4ee5\u672b\u679d\u6709actYes,\u5373\u5f53\u524dcurModel\u4e5f\u4e0d\u5e94\u54cd\u5e94 (\u53c2\u800326184-\u539f\u5219);\n *  @version\n *      2023.03.04: \u5224\u65ad\u672b\u679d\u8981\u6392\u9664subDemand\u7684\u5f71\u54cd (\u53c2\u800328143-\u56de\u6d4b & \u4fee\u590d);\n *      2023.08.19: \u672b\u679d\u4e0d\u6392\u9664hDemandModel (\u53c2\u800330113-todo1);"
        },
        {
            "comment": "This code seems to be part of a larger program and contains two separate methods. The first method, `endHavActYes`, checks if there is any valid \"ActYes\" status sub-model at the deepest level in the provided model hierarchy. The second method, `mergeCansets`, takes an array of \"AIEffectStrong\" objects (presumably representing different solutions or options) and merges them based on a shared \"fo\" parameter. Both methods seem to be unrelated to each other in terms of functionality.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":586-612",
            "content": " */\n+(BOOL) endHavActYes:(TOModelBase*)curModel{\n    NSArray *allSubModels = [TOUtils getSubOutModels_AllDeep:curModel validStatus:nil];\n    BOOL endHavActYes = [SMGUtils filterSingleFromArr:allSubModels checkValid:^BOOL(TOModelBase *item) {\n        //1. \u5224\u65ad\u662fActYes\u72b6\u6001;\n        if (item.status == TOModelStatus_ActYes) {\n            //2. \u5224\u65ad\u662f\u672b\u679d (\u5176\u4e0b\u6709Demand\u4e0d\u7b97) (\u53c2\u800328143-\u4fee\u590d);\n            NSArray *subModels = [TOUtils getSubOutModels:item];\n            subModels = [SMGUtils filterArr:subModels checkValid:^BOOL(id item) {\n                return !ISOK(item, ReasonDemandModel.class);\n            }];\n            return subModels.count == 0;\n        }\n        return false;\n    }];\n    return endHavActYes;\n}\n/**\n *  MARK:--------------------\u5c06cansets\u4e2d\u540cfo\u7684strong\u5408\u5e76--------------------\n */\n+(NSArray*) mergeCansets:(NSArray*)protoCansets{\n    NSMutableDictionary *cansetsDic = [[NSMutableDictionary alloc] init];\n    for (AIEffectStrong *item in protoCansets) {\n        //a. \u53d6\u65e7;\n        id key = @(item.solutionFo.pointerId);\n        AIEffectStrong *old = [cansetsDic objectForKey:key];"
        },
        {
            "comment": "The code adds an effect to an existing item, updating its strength values and storing it in a dictionary.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Out/TOUtils.m\":613-624",
            "content": "        if (!old) old = [AIEffectStrong newWithSolutionFo:item.solutionFo];\n        //b. \u66f4\u65b0;\n        old.hStrong += item.hStrong;\n        old.nStrong += item.nStrong;\n        [cansetsDic setObject:old forKey:key];\n    }\n    return cansetsDic.allValues;\n}\n@end"
        }
    ]
}