{
    "summary": "This code compares TOMVisionItemModel objects, counts differences, and includes functions for dictionary changes, indices, range calculations, node descriptions, and checks if a point is inside a rectangular area. Objective-C calculates node offsets and formats string representations based on types.",
    "details": [
        {
            "comment": "This code is part of the TVUtil class in the SMG_NothingIsAll project. It defines a method called getChange_List which takes an array of models as input and returns a mutable dictionary of changes between each pair of consecutive frames in the model array. The function first checks if the input array is valid, and then iterates through each pair of frames to obtain the differences between them and stores them in the result dictionary.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":0-38",
            "content": "//\n//  TVUtil.m\n//  SMG_NothingIsAll\n//\n//  Created by jia on 2022/3/26.\n//  Copyright \u00a9 2022\u5e74 XiaoGang. All rights reserved.\n//\n#import \"TVUtil.h\"\n#import \"TOModelVisionUtil.h\"\n#import \"UnorderItemModel.h\"\n#import \"TOMVisionItemModel.h\"\n@implementation TVUtil\n/**\n *  MARK:--------------------\u83b7\u53d6\u6240\u6709\u5e27\u5de5\u4f5c\u8bb0\u5fc6\u7684\u4e24\u4e24\u66f4\u65b0\u6bd4\u5bf9--------------------\n *  @desc \u6ce8: \u5305\u62ec\u9996\u5e27\u65f6,\u4e5f\u8981\u548c-1\u5e27nil\u6bd4\u5bf9;\n *  @result notnull;\n *      1. \u7c7b\u578b: DIC<K:\u540e\u5e27\u4e0b\u6807, V:\u53d8\u5316\u6570\u7ec4>\n *      2. \u8303\u56f4: key\u8303\u56f4\u4e3a:\"0 -> models.count-1\";\n */\n+(NSMutableDictionary*) getChange_List:(NSArray*)models {\n    //1. \u6570\u636e\u68c0\u67e5;\n    NSMutableDictionary *result = [[NSMutableDictionary alloc] init];\n    if (!ARRISOK(models)) return result;\n    //2. \u4e24\u4e24\u6bd4\u5bf9;\n    for (NSInteger b = 0; b < models.count; b++) {\n        TOMVisionItemModel *itemB = ARR_INDEX(models, b);\n        TOMVisionItemModel *itemA = ARR_INDEX(models, b - 1);\n        NSArray *itemChanges = [self getChange_Item:itemA itemB:itemB];\n        [result setObject:itemChanges forKey:@(b)];\n    }\n    return result;\n}\n/**\n *  MARK:--------------------\u83b7\u53d6\u4e24\u5e27\u5de5\u4f5c\u8bb0\u5fc6\u7684\u66f4\u65b0\u5904--------------------"
        },
        {
            "comment": "This code contains a method that compares two TOMVisionItemModel objects, itemA and itemB, to find the changes between them. It prepares data by collecting all sub TO models under each item's roots and returns the count of new items in itemB that are not present in itemA as the result. The method also includes a nested collectAllSubTOModelByRoots function to gather sub-models under specified roots.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":39-69",
            "content": " *  @result itemB\u4e2d\u65b0\u589e\u7684\u53d8\u5316\u6570 notnull;\n */\n+(NSArray*) getChange_Item:(TOMVisionItemModel*)itemA itemB:(TOMVisionItemModel*)itemB{\n    //1. \u6570\u636e\u51c6\u5907;\n    NSArray *subsA = itemA ? [self collectAllSubTOModelByRoots:itemA.roots] : [NSArray new];\n    NSArray *subsB = itemB ? [self collectAllSubTOModelByRoots:itemB.roots] : [NSArray new];\n    //2. \u5c06\u66f4\u65b0\u8fd4\u56de (second\u5305\u542b & first\u4e0d\u5305\u542b);\n    return [SMGUtils filterArr:subsB checkValid:^BOOL(id item) {\n        return ![subsA containsObject:item];\n    }];\n}\n//\u6536\u96c6roots\u4e0b\u9762\u6240\u6709\u7684\u679d\u53f6 notnull;\n+(NSMutableArray*) collectAllSubTOModelByRoots:(NSArray*)roots {\n    //1. \u6570\u636e\u51c6\u5907;\n    NSMutableArray *result = [[NSMutableArray alloc] init];\n    roots = ARRTOOK(roots);\n    //2. \u6536\u96c6\n    for (DemandModel *root in roots) {\n        NSMutableArray *unorderModels = [TOModelVisionUtil convertCur2Sub2UnorderModels:root];\n        [result addObjectsFromArray:[SMGUtils convertArr:unorderModels convertBlock:^id(UnorderItemModel *obj) {\n            return obj.data;\n        }]];\n    }\n    return result;\n}\n/**\n *  MARK:--------------------changeDic\u7684\u53d8\u5316\u603b\u6570--------------------"
        },
        {
            "comment": "The code provides methods to count the number of changes in a dictionary and find the main and sub indices corresponding to a given change index. The \"TVUtil\" class contains functions that operate on dictionaries, accumulate change counts, and retrieve specific indices based on change indices.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":70-101",
            "content": " *  @result \u53d6\u503c\u4e3a1-length\n */\n+(NSInteger) countOfChangeDic:(NSDictionary*)changeDic{\n    //1. \u6570\u636e\u51c6\u5907;\n    changeDic = DICTOOK(changeDic);\n    NSInteger result = 0;\n    //2. \u7d2f\u8ba1changeCount;\n    for (NSArray *value in changeDic.allValues) {\n        result += MAX(1, value.count);\n    }\n    return result;\n}\n/**\n *  MARK:--------------------changeIndex\u8f6cindex--------------------\n *  @result \u8fd4\u56deNSRange\u7684\u7b2c1\u4f4d\u8868\u793amainIndex,\u7b2c2\u4f4d\u8868\u793asubIndex\n *      1. \u672a\u627e\u5230\u7ed3\u679c\u65f6\u4e3a-1;\n *      2. \u5176\u4e2dmainIndex\u548csubIndex\u7684\u8303\u56f4\u90fd\u662f: 0 -> count-1;\n */\n+(NSInteger) mainIndexOfChangeIndex:(NSInteger)changeIndex changeDic:(NSDictionary*)changeDic{\n    return [self indexOfChangeIndex:changeIndex changeDic:changeDic].location;\n}\n+(NSInteger) subIndexOfChangeIndex:(NSInteger)changeIndex changeDic:(NSDictionary*)changeDic{\n    return [self indexOfChangeIndex:changeIndex changeDic:changeDic].length;\n}\n+(NSRange) indexOfChangeIndex:(NSInteger)changeIndex changeDic:(NSDictionary*)changeDic {\n    //1. \u6570\u636e\u51c6\u5907;\n    changeDic = DICTOOK(changeDic);\n    NSInteger sumChangeCount = 0;\n    //2. \u7d2f\u8ba1changeCount (key\u8303\u56f4\u53c2\u8003getChange_List()\u7684key\u8303\u56f4\u8bf4\u660e);"
        },
        {
            "comment": "The code is calculating a range based on the count of elements in an array. If the sum of counts does not reach the target index, it accumulates the current count and continues to iterate through the for loop. Otherwise, if the target is reached within the current key, it returns the range starting from that key index. The code also calculates a distanceY description based on whether the value is in-screen or out-of-screen, using formatted strings to display the values.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":102-131",
            "content": "    for (NSInteger k = 0; k < changeDic.count; k++) {\n        NSArray *value = [changeDic objectForKey:@(k)];\n        //3. \u76ee\u6807\u4e3achangeIndex+1,\u5f53\u524dsum+valueCount\u5c0f\u4e8e\u76ee\u6807\u65f6,\u8bf4\u660e\u4ecd\u672a\u8fbe\u5230,\u7d2f\u8ba1\u5e76\u7ee7\u7eedfor\u5411\u4e0b\u627e;\n        if (sumChangeCount + MAX(1, value.count) < changeIndex + 1) {\n            sumChangeCount += MAX(1, value.count);\n        }else {\n            //4. \u5426\u5219,\u8bf4\u660e\u8981\u627e\u7684\u76ee\u6807\u5c31\u5728\u5f53\u524dkey\u4e2d;\n            NSInteger mainIndex = k;\n            NSInteger subIndex = value.count ? changeIndex - sumChangeCount : -1;\n            return NSMakeRange(mainIndex, subIndex);\n        }\n    }\n    return NSMakeRange(-1, -1);\n}\n+(NSString*) distanceYDesc:(CGFloat)distanceY{\n    //1. \u4e2d\u95f4\u70b9\u662f35,\u8f6c\u6210\u4e2d\u95f4\u70b9\u4e3a0;\n    CGFloat centerDistanceY = distanceY - 50 + 15;\n    //2. \u51fa\u5c4f\n    if(centerDistanceY < -ScreenHeight * 0.5f){\n        return STRFORMAT(@\"\u4e0a\u51fa\u5c4f%.0f\",centerDistanceY + ScreenHeight * 0.5f);\n    }else if(centerDistanceY > ScreenHeight * 0.5f) {\n        return STRFORMAT(@\"\u4e0b\u51fa\u5c4f%.0f\",centerDistanceY - ScreenHeight * 0.5f);\n    }\n    //2. \u5c4f\u5185\n    CGFloat yPos = [self onRoadDistanceY:distanceY];"
        },
        {
            "comment": "The code returns different descriptions based on the y position of a node. It also calculates the distance of a point from the road, returning values between -1 and 1 to represent the degree of being offset above or below the road. Finally, it gets a light string for a given array of nodes and a flag indicating if it's the header node.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":132-168",
            "content": "    if (yPos > 1) {\n        return STRFORMAT(@\"\u8def\u4e0b%.1f\",yPos);\n    }else if (yPos > 0) {\n        return STRFORMAT(@\"\u504f\u4e0b%.1f\",yPos);\n    }else if (yPos == 0) {\n        return @\"\u6b63\u4e2d\";\n    }else if (yPos > -1) {\n        return STRFORMAT(@\"\u504f\u4e0a%.1f\",-yPos);\n    }else{\n        return STRFORMAT(@\"\u8def\u4e0a%.1f\",-yPos);\n    }\n}\n/**\n *  MARK:--------------------\u8def\u4e0a\u7684\u4f4d\u7f6e: \u504f\u4e0a\u6216\u504f\u4e0b--------------------\n *  @result -1\u52301 (\u6b63\u504f\u4e0b,\u8d1f\u504f\u4e0a);\n */\n+(CGFloat) onRoadDistanceY:(CGFloat)distanceY{\n    //1. \u4e2d\u95f4\u70b9\u662f35,\u8f6c\u6210\u4e2d\u95f4\u70b9\u4e3a0;\n    CGFloat centerDistanceY = distanceY - 50 + 15;\n    //2. \u51fa\u8def\u8ddd\u79bb;\n    CGFloat roadH = 100,birdH = 30;\n    CGFloat outRoadDistance = (roadH + birdH) * 0.5f;\n    //2. \u504f\u4e0a\u4e3a0\u5230-1,\u504f\u4e0b\u4e3a0\u52301 (0\u4e3a\u4e2d\u5fc3,1\u548c-1\u662f\u8def\u8fb9\u7f18\u70b9);\n    CGFloat result = centerDistanceY / outRoadDistance;\n    return result;\n}\n//MARK:===============================================================\n//MARK:                     < \u8282\u70b9\u63cf\u8ff0 >\n//MARK:===============================================================\n+(NSString*) getLightStr4Ps:(NSArray*)node_ps header:(BOOL)header{\n    //1. \u6570\u636e\u68c0\u67e5\n    NSMutableString *result = [[NSMutableString alloc] init];"
        },
        {
            "comment": "This code seems to be part of a larger program written in Objective-C. It appears to be responsible for parsing and formatting data structures into strings. The 'getLightStr' function is used to retrieve a string representation of certain nodes based on their types (value, algorithm, or feature). The main function (assumed to be named \"TVUtil\") concatenates the resulting strings from each node in a list (node_ps), adding \"_\" or \",\" depending on whether the node is a value or not. Finally, it removes the last character if it's an underscore or comma before returning the result.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":169-197",
            "content": "    node_ps = ARRTOOK(node_ps);\n    //2. \u62fc\u63a5\u8fd4\u56de\n    for (AIKVPointer *item_p in node_ps){\n        NSString *str = [self getLightStr:item_p header:header];\n        if (STRISOK(str)) {\n            [result appendFormat:@\"%@%@\",str,PitIsValue(item_p) ? @\"_\" : @\",\"];\n        }\n    }\n    return SUBSTR2INDEX(result, result.length - 1);\n}\n+(NSString*) getLightStr:(AIKVPointer*)node_p {\n    return [self getLightStr:node_p header:true];\n}\n+(NSString*) getLightStr:(AIKVPointer*)node_p header:(BOOL)header{\n    NSString *lightStr = @\"\";\n    if (ISOK(node_p, AIKVPointer.class)) {\n        if (PitIsValue(node_p)) {\n            lightStr = [self getLightStr_ValueP:node_p];\n        }else if (PitIsAlg(node_p)) {\n            AIAlgNodeBase *algNode = [SMGUtils searchNode:node_p];\n            if (algNode) {\n                lightStr = [self getLightStr4Ps:algNode.content_ps header:header];\n            }\n        }else if(PitIsFo(node_p)){\n            AIFoNodeBase *foNode = [SMGUtils searchNode:node_p];\n            if (foNode) {\n                lightStr = [self getLightStr4Ps:foNode.content_ps header:header];"
        },
        {
            "comment": "This function returns a light string based on the node_p parameter. If node_p represents a MV value, it calculates and formats a score string with additional information. The function then decorates the header if provided and returns the final light string. Another function is defined to retrieve the light description for a specific value_p object by converting its numerical value to a string and adding specific descriptions based on the data source attribute.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":198-224",
            "content": "            }\n        }else if(PitIsMv(node_p)){\n            CGFloat score = [AIScore score4MV:node_p ratio:1.0f];\n            lightStr = STRFORMAT(@\"%@%@%@\",Mvp2DeltaStr(node_p),Class2Str(NSClassFromString(node_p.algsType)),Double2Str_NDZ(score));\n        }\n    }\n    //2. \u8fd4\u56de;\n    if (header) lightStr = [self decoratorHeader:lightStr node_p:node_p];\n    return lightStr;\n}\n//\u83b7\u53d6value_p\u7684light\u63cf\u8ff0;\n+(NSString*) getLightStr_ValueP:(AIKVPointer*)value_p{\n    if (!value_p) return @\"\";\n    double value = [NUMTOOK([AINetIndex getData:value_p]) doubleValue];\n    NSString *valueStr = [self getLightStr_Value:value algsType:value_p.algsType dataSource:value_p.dataSource];\n    if ([@\"sizeHeight\" isEqualToString:value_p.dataSource]) {\n        if (value == 30) {\n            return @\"\u9e1f\";\n        }else if(value == 100) {\n            return @\"\u68d2\";\n        }else if(value == 5) {\n            return @\"\u679c\";\n        }\n        return STRFORMAT(@\"\u9ad8%@\",valueStr);\n    }else if ([@\"distanceY\" isEqualToString:value_p.dataSource]) {\n        return [TVUtil distanceYDesc:value];"
        },
        {
            "comment": "This code includes several methods that convert numerical values into specific light descriptors or strings based on a given algorithm type and data source. The functions use conditional statements to determine the appropriate conversion method, such as \"fly2Str\", \"direction2Str\", or a default conversion function. These methods are used for decorating headers with pointers and converting various lights' descriptions based on the input parameters like algorithms type, value, and data source.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":225-249",
            "content": "    }else if([FLY_RDS isEqualToString:value_p.algsType]){\n        return STRFORMAT(@\"%@\",valueStr);\n    }else if([KICK_RDS isEqualToString:value_p.algsType]){\n        return STRFORMAT(@\"%@\",valueStr);\n    }\n    return @\"\";//valueStr\n}\n//\u83b7\u53d6value\u7684light\u63cf\u8ff0;\n+(NSString*) getLightStr_Value:(double)value algsType:(NSString*)algsType dataSource:(NSString*)dataSource{\n    if([FLY_RDS isEqualToString:algsType]){\n        return [NVHeUtil fly2Str:value];\n    }else if([@\"direction\" isEqualToString:dataSource]){\n        return [NVHeUtil direction2Str:value];\n    }else if([KICK_RDS isEqualToString:dataSource]){\n        return STRFORMAT(@\"\u8e22%@\",[NVHeUtil fly2Str:value]);\n    }\n    return Double2Str_NDZ(value);\n}\n//MARK:===============================================================\n//MARK:                     < privateMethod >\n//MARK:===============================================================\n+(NSString*) decoratorHeader:(NSString*)lightStr node_p:(AIKVPointer*)node_p{\n    NSString *pIdStr = node_p ? STRFORMAT(@\"%ld\",node_p.pointerId) : @\"\";"
        },
        {
            "comment": "This code checks the type of a node and returns a formatted string accordingly. If the node is an algorithm, it returns the light string. If the node is a feature object, it formats the light string within square brackets. If the node is a move object, it formats \"M\" followed by the piece id and the light string. Additionally, there's a separate function that checks whether a point is inside a rectangular area.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/TOMVision2/Util/TVUtil.m\":250-273",
            "content": "    if (PitIsAlg(node_p)) {\n        return lightStr;\n    }else if(PitIsFo(node_p)){\n        return STRFORMAT(@\"[%@]\",lightStr);\n    }else if(PitIsMv(node_p)){\n        return STRFORMAT(@\"M%@{%@}\",pIdStr,lightStr);\n    }\n    return lightStr;\n}\n//MARK:===============================================================\n//MARK:                     < UI\u4e0eView\u76f8\u5173 >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u70b9\u5728\u6846\u5185--------------------\n */\n+(BOOL) inRect:(CGRect)rect point:(CGPoint)point{\n    BOOL inX = point.x >= CGRectGetMinX(rect) && point.x <= CGRectGetMaxX(rect);\n    BOOL inY = point.y >= CGRectGetMinY(rect) && point.y <= CGRectGetMaxY(rect);\n    return inX && inY;\n}\n@end"
        }
    ]
}