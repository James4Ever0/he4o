{
    "summary": "The code optimizes filtering and sorting for concept recognition, limits matches to 4, calculates values, deprecates old functions, and selects strongest items in Ports2Pits format with valid scene conditions using a 5-step process and ensures result is within specified range.",
    "details": [
        {
            "comment": "This code contains two filter methods: recognitionAlgFilter and timeSequenceFilter, which are used for concept recognition and time sequence recognition. The recognitionAlgFilter uses a matching value and strong value to filter the matchAlgModels array, while the timeSequenceFilter filters the time sequence models based on matching value and strong value. Both filters can be adjusted with different radio values, min and max limits, and debug mode options.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":0-32",
            "content": "//\n//  AIFilter.m\n//  SMG_NothingIsAll\n//\n//  Created by jia on 2023/2/25.\n//  Copyright \u00a9 2023\u5e74 XiaoGang. All rights reserved.\n//\n#import \"AIFilter.h\"\n@implementation AIFilter\n/**\n *  MARK:--------------------\u6982\u5ff5\u8bc6\u522b\u8fc7\u6ee4\u5668--------------------\n *  @version\n *      2023.03.06: \u6982\u5ff5\u8bc6\u522b\u8fc7\u6ee4\u5668\u5339\u914d\u5ea6\u4e3a\u4e3b,\u5f3a\u5ea6\u4e3a\u8f85 (\u53c2\u800328152-\u65b9\u68484-todo4);\n *      2023.06.01: BUG_\u6709\u4e86\u8bc6\u522b\u4e8c\u6b21\u8fc7\u6ee4\u540e,\u8fc7\u6ee4\u592a\u5f3a\u5bfc\u81f4\u6700\u540e\u7684pFos\u5269\u4e0b0-2\u6761\u592a\u5c11\u4e86,\u6240\u4ee5\u6b64\u5904\u51cf\u5f31\u4e00\u4e0b\u8fc7\u6ee4\u529b\u5ea6;\n *      2023.06.01: pAlgs\u548crAlgs\u652f\u6301\u4f20\u5165\u4e0d\u540c\u7684radio\u8fc7\u6ee4\u503c (\u53c2\u800329108-2.1);\n */\n+(NSArray*) recognitionAlgFilter:(NSArray*)matchAlgModels radio:(CGFloat)radio {\n    return [self filterTwice:matchAlgModels mainBlock:^double(AIMatchAlgModel *item) {\n        return item.matchValue;\n    } subBlock:^double(AIMatchAlgModel *item) {\n        return item.strongValue;\n    } radio:radio min:10 max:20 debugMode:true];\n}\n/**\n *  MARK:--------------------\u65f6\u5e8f\u8bc6\u522b\u8fc7\u6ee4\u5668--------------------\n *  @version\n *      2023.03.06: \u65f6\u5e8f\u8bc6\u522b\u8fc7\u6ee4\u5668\u5f3a\u5ea6\u4e3a\u4e3b,\u5339\u914d\u5ea6\u4e3a\u8f85 (\u53c2\u800328152-\u65b9\u68484-todo5);\n *      2023.03.18. \u75310.16\u8c03\u6574\u4e3a0.6 (\u6982\u5ff5\u5df2\u7ecf\u5f88\u51c6\u4e86,\u65f6\u5e8f\u53ea\u8981\u628a\u4e0d\u51c6\u90e8\u5206\u5207\u4e86\u5c31\u884c,\u4e0d\u9700\u8981\u8fc7\u6ee4\u592a\u591a);\n *      2023.06.01: \u52a0\u4e0a\u8bc6\u522b\u4e8c\u6b21\u8fc7\u6ee4\u540e,\u7b2c\u4e00\u6b21\u4e0d\u9700\u8981\u8fc7\u6ee4\u5339\u914d\u5ea6\u4e86,\u4ec5\u6392\u9664\u4e00\u4e0b\u5f3a\u5ea6\u592a\u5f31\u7684\u672b\u5c3e\u5373\u53ef (\u53c2\u800329108-1);"
        },
        {
            "comment": "This method `recognitionFoFilter` applies a filter to the given `matchModels` array, returning only a subset of items based on their \"strongValue\" property. The `mainBlock` is used to extract this value from each item in the array. Additionally, there are comments mentioning previous versions and changes made to the code over time.\n\nCode comments suggest that this function was initially developed for Canset recognition but is now deprecated (as of 2023.10.26). Another function called `recognitionCansetFilter` was previously used for Canset recognition filtering, sorting the `matchModels` array based on each item's \"indexDic\" count and then applying a radio-based filter. This function is also deprecated now (as of 2023.10.26).\n\nFinally, there is an ongoing task to develop a Canset solving filter as mentioned in `recognitionCansetSolveFilter` with a todo number `29081-todo41`.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":33-59",
            "content": " */\n+(NSArray*) recognitionFoFilter:(NSArray*)matchModels {\n    return [self filterOnce:matchModels mainBlock:^double(AIMatchFoModel *item) {\n        return item.strongValue;\n    } radio:0.8f min:8 max:20];\n}\n/**\n *  MARK:--------------------Canset\u8bc6\u522b\u8fc7\u6ee4\u5668 (\u53c2\u800329042)--------------------\n *  @desc \u521d\u7248Canset\u8bc6\u522b\u56e0\u4e3a\u7ed3\u679c\u592a\u591a\u518d\u7c7b\u6bd4\u65f6\u6027\u80fd\u5dee,\u52a0\u8fc7\u6ee4\u5668\u4f53\u73b0\u7ade\u4e89 (\u53c2\u800329042);\n *  @version\n *      2023.04.04: \u5c06\u8fc7\u6ee4\u5668\u7531SP\u4e3bEFF\u8f85,\u6539\u4e3a\u6620\u5c04\u6570\u4e3a\u4e3bSP\u4e3a\u8f85 (\u53c2\u800329055-\u65b9\u6848);\n *      2023.10.26: \u5e9f\u5f03canset\u8bc6\u522b (\u53c2\u80033014c-todo2);\n */\n//+(NSArray*) recognitionCansetFilter:(NSArray*)matchModels sceneFo:(AIFoNodeBase*)sceneFo {\n//    CGFloat radio = 0.2f;\n//    NSArray *result = ARR_SUB([SMGUtils sortBig2Small:matchModels compareBlock:^double(AIMatchCansetModel *obj) {\n//        return obj.indexDic.count;\n//    }], 0, matchModels.count * radio);\n//    NSLog(@\"Canset\u8bc6\u522b\u8fc7\u6ee4\u5668: \u603b%ld * \u9700%.0f%% => \u5269:%ld\",matchModels.count,radio * 100,result.count);\n//    return result;\n//}\n/**\n *  MARK:--------------------Canset\u6c42\u89e3\u8fc7\u6ee4\u5668 (\u53c2\u800329081-todo41)--------------------\n *  @version\n *      2023.09.04: \u52a0\u4e0ahStrong\u505a\u4e8c\u7ea7\u6392\u5e8f\u56e0\u5b50 (\u53c2\u800330125-\u65b9\u6848);"
        },
        {
            "comment": "Code optimizes sort performance by prefetching getEffectStrong(), converts canset array to MapModel, sorts the models based on effect scores and strong values, then converts back to canset array.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":60-82",
            "content": " *      2023.12.26: \u4f18\u5316sort\u6027\u80fd,\u628agetEffectStrong()\u63d0\u51fa\u6765\u63d0\u524d\u53d6\u597d (\u53c2\u800331025-\u4ee3\u7801\u6bb5-\u95ee\u98981) //\u5171\u4e09\u5904\u4f18\u5316,\u6b64\u4e43\u5176\u4e00;\n */\n+(NSArray*) solutionCansetFilter:(AIFoNodeBase*)sceneFo targetIndex:(NSInteger)targetIndex {\n    NSArray *protoConCansets = [sceneFo getConCansets:targetIndex];\n    //1. canset\u6570\u7ec4\u8f6c\u6210mapModel (\u63d0\u524d\u628astrong\u90fd\u53d6\u51fa\u6765,\u907f\u514d\u540e\u9762\u5728\u6392\u5e8f\u65f6\u8bbf\u95ee\u592a\u591a\u6b21\u800c\u5361\u6027\u80fd);\n    NSArray *mapArr = [SMGUtils convertArr:protoConCansets convertBlock:^id(AIKVPointer *canset) {\n        AIEffectStrong *strong = [TOUtils getEffectStrong:sceneFo effectIndex:targetIndex solutionFo:canset];\n        return [MapModel newWithV1:canset v2:strong];\n    }];\n    //2. \u5bf9mapModelArr\u6392\u5e8f;\n    NSArray *sorts = [SMGUtils sortBig2Small:mapArr compareBlock1:^double(MapModel *mapModel) {\n        return [TOUtils getEffectScore:mapModel.v2];\n    } compareBlock2:^double(MapModel *mapModel) {\n        AIEffectStrong *strong = mapModel.v2;\n        return strong.hStrong;\n    }];\n    //3. sort\u518d\u8f6c\u56decanset\u6570\u7ec4;\n    sorts = [SMGUtils convertArr:sorts convertBlock:^id(MapModel *obj) {\n        return obj.v1;\n    }];"
        },
        {
            "comment": "This code filters second-round matches for a model using recognition utilities, updating the operation count, and setting a limit of 4 matches. If there are less than 4 matches, no further filtering is done. The code then gets a dictionary of importance values from the recognizer utility based on the input model and calculates second-round match values for each algorithm in the model.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":83-106",
            "content": "    NSInteger limit = MAX(3, protoConCansets.count * 0.2f);//\u53d620% & \u81f3\u5c11\u5c1d\u8bd5\u53d63\u6761;\n    return ARR_SUB(sorts, 0, limit);\n}\n/**\n *  MARK:--------------------\u8bc6\u522b\u4e8c\u6b21\u8fc7\u6ee4\u5668--------------------\n *  @version\n *      2023.05.31: \u56de\u6d4b\u6982\u5ff5\u8bc6\u522b\u4e8c\u6b21\u8fc7\u6ee4ok,\u5c31\u662f\u4fdd\u755960%\u6709\u70b9\u591a,\u8c03\u621040%;\n *      2023.06.04: BUG_\u4fee\u590d\u65f6\u5e8f\u8fc7\u6ee4\u6761\u6570\u6709\u4e0d\u786e\u5b9a\u6027 (\u53c2\u800329109-\u6d4b\u5f974);\n *      2023.06.06: \u8fc7\u6ee4\u51fa20%\u7684\u7ed3\u679c\u4f9d\u7136\u592a\u591a,\u76f4\u63a5\u6539\u62104\u6761,\u5c0f\u4e8e4\u6761\u65f6\u76f4\u63a5return\u4e0d\u8fc7\u6ee4 (\u53c2\u800330013);\n */\n+(void) secondRecognitionFilter:(AIShortMatchModel*)inModel {\n    //1. \u83b7\u53d6V\u91cd\u8981\u6027\u5b57\u5178;\n    [theTC updateOperCount:kFILENAME];\n    NSInteger foLimit = 4;//MAX(4, inModel.matchPFos.count * 0.2f);\n    if (inModel.matchPFos.count <= foLimit) return;//\u5c0f\u4e8elimit\u6761\u65f6,\u4e0d\u7528\u4e8c\u6b21\u8fc7\u6ee4;\n    IFTitleLog(@\"\u8bc6\u522b\u4e8c\u6b21\u8fc7\u6ee4\",@\"\\nfrom protoFo:%@\",Fo2FStr(inModel.protoFo));\n    BOOL debugMode = false;\n    NSDictionary *importanceDic = [TCRecognitionUtil getVImportanceDic:inModel];\n    //2. \u6839\u636e\u91cd\u8981\u6027\u52a0\u6743\u8ba1\u7b97\u4e8c\u6b21\u8fc7\u6ee4\u5339\u914d\u5ea6 (\u53c2\u800329107-\u6b65\u9aa42) (\u6027\u80fd: \u8017\u65f642ms);\n    NSMutableDictionary *secondMatchValueDic = [[NSMutableDictionary alloc] init];\n    for (AIMatchAlgModel *item in inModel.matchAlgs) {\n        double secondMatchValue = 1;"
        },
        {
            "comment": "This code performs a second-level filtering on the concept recognition results, where it iterates through each match algorithm and calculates the secondMatchValue by considering the importance of the corresponding prototype values. Then, it sorts the matchAlgs based on their secondMatchValues in descending order to apply the second-level filter.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":107-124",
            "content": "        AIAlgNodeBase *matchAlg = [SMGUtils searchNode:item.matchAlg];\n        for (AIKVPointer *protoV_p in inModel.protoAlg.content_ps) {\n            for (AIKVPointer *matchV_p in matchAlg.content_ps) {\n                if ([protoV_p.identifier isEqualToString:matchV_p.identifier]) {\n                    //3. \u4e8c\u6b21\u8fc7\u6ee4V\u76f8\u8fd1\u5ea6 = \u539fV\u76f8\u8fd1\u5ea6 \u7684 \u91cd\u8981\u6027\u6b21\u65b9 (\u53c2\u800329107-\u6b65\u9aa42);\n                    CGFloat nearV = [AIAnalyst compareCansetValue:matchV_p protoValue:protoV_p vInfo:nil];\n                    double importance = NUMTOOK_DV([importanceDic objectForKey:protoV_p.identifier],1).doubleValue;\n                    secondMatchValue *= powf(nearV, importance);\n                }\n            }\n        }\n        [secondMatchValueDic setObject:@(secondMatchValue) forKey:@(matchAlg.pId)];\n    }\n    //4. \u6982\u5ff5\u8bc6\u522b\u7684\u4e8c\u6b21\u6392\u5e8f\u8fc7\u6ee4 (\u4fdd\u755960% & \u81f3\u5c11\u4fdd\u75594\u6761) (\u53c2\u800329107-todo1);\n    NSArray *sort = [SMGUtils sortBig2Small:inModel.matchAlgs compareBlock:^double(AIMatchAlgModel *obj) {\n        return NUMTOOK([secondMatchValueDic objectForKey:@(obj.matchAlg.pointerId)]).doubleValue;"
        },
        {
            "comment": "Code chunk initializes two empty arrays, filterAlgs and filterFos. It then iterates through each item in the sorted array, adding the current item to filterAlgs and collecting its corresponding pFos (stopping when there are enough foLimit items).",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":125-142",
            "content": "    }];\n    if (debugMode) for (AIMatchAlgModel *item in sort) NSLog(@\"\u770b\u4e0d\u91cd\u8981\u7684\u88ab\u6392\u5230\u4e86\u540e\u9762\u65e5\u5fd7: %ld \u73b0\u5339\u914d\u5ea6:%.2f (\u539f%.2f) %@\",[sort indexOfObject:item],NUMTOOK([secondMatchValueDic objectForKey:@(item.matchAlg.pointerId)]).doubleValue,item.matchValue,Pit2FStr(item.matchAlg));\n    //5. \u4fdd\u7559\u65f6\u5e8f30% & \u81f3\u5c114\u6761;\n    [AITest test28:inModel];\n    NSMutableArray *filterAlgs = [[NSMutableArray alloc] init];\n    NSMutableArray *filterFos = [[NSMutableArray alloc] init];\n    for (AIMatchAlgModel *aItem in sort) {\n        //6. \u5c06\u5f53\u524daItem\u6536\u96c6;\n        [filterAlgs addObject:aItem];\n        //7. \u5e76\u6536\u96c6aItem\u5b83\u5bf9\u5e94\u7684pFos (\u6536\u96c6\u591ffoLimit\u6761\u65f6break) (\u53c2\u800329107-todo2 & 29109-\u6d4b\u5f974);\n        [filterFos addObjectsFromArray:[SMGUtils filterArr:inModel.matchPFos checkValid:^BOOL(AIMatchFoModel *item) {\n            AIFoNodeBase *pFo = [SMGUtils searchNode:item.matchFo];\n            AIKVPointer *cutIndexAlg_p = ARR_INDEX(pFo.content_ps, item.cutIndex);//\u53d6\u521a\u53d1\u751f\u7684alg;\n            return [cutIndexAlg_p isEqual:aItem.matchAlg];\n        }]];\n        if (filterFos.count >= foLimit) break;"
        },
        {
            "comment": "This code snippet performs a second-level filter on the match algorithms and time-series data for a given model. It logs the number of matches before and after filtering, then stores the filtered results in the model's matchAlgs and matchPFos arrays. The function secondActionRecognitionFilter takes an AIShortMatchModel as input, groups the match data by type, and selects the most urgent item for each group.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":143-162",
            "content": "    }\n    //7. debugLog\n    NSLog(@\"\u6982\u5ff5\u4e8c\u6b21\u8fc7\u6ee4\u540e\u6761\u6570: \u539f%ld \u5269%ld >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\",inModel.matchAlgs.count,filterAlgs.count);\n    for (AIMatchAlgModel *item in filterAlgs) if (debugMode) NSLog(@\"\\t%ld. %@ (\u73b0\u5339\u914d\u5ea6:%.2f \u539f%.2f)\",[filterAlgs indexOfObject:item] + 1,Pit2FStr(item.matchAlg),NUMTOOK([secondMatchValueDic objectForKey:@(item.matchAlg.pointerId)]).doubleValue,item.matchValue);\n    NSLog(@\"\\n\u65f6\u5e8f\u4e8c\u6b21\u8fc7\u6ee4\u540e\u6761\u6570: \u539f%ld \u5269%ld >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\",inModel.matchPFos.count,filterFos.count);\n    for (AIMatchFoModel *item in filterFos) NSLog(@\"\\t%ld. %@\",[filterFos indexOfObject:item] + 1,Pit2FStr(item.matchFo));\n    //8. \u5b58\u4e0b\u7ed3\u679c;\n    inModel.matchAlgs = filterAlgs;\n    inModel.matchPFos = filterFos;\n}\n/**\n *  MARK:--------------------\u884c\u4e3a\u5316\u524d\u53cd\u601d\u8bc6\u522b\u8fc7\u6ee4\u5668 (\u53c2\u800330059)--------------------\n *  @desc \u6839\u636emv\u7c7b\u578b\u5206\u7ec4,\u7136\u540e\u8fc7\u6ee4\u51fa\u6bcf\u7ec4\u8feb\u5207\u5ea6\u6700\u5f3a\u7684\u4e00\u6761 (\u53c2\u800330059-\u65b9\u6848);\n *  @version\n *      2023.07.13: \u6539\u6210matchPFos\u9ed8\u8ba4\u6392\u5e8f\u65b9\u5f0f\u4e0d\u53d8,\u4ec5\u622a\u53d6\u6bcf\u79cdmv\u7c7b\u578b\u7684\u524d3\u6761 (\u53c2\u800330059-\u65b9\u68482);\n */\n+(void) secondActionRecognitionFilter:(AIShortMatchModel*)inModel {  "
        },
        {
            "comment": "This code groups matchPFos by their algsType, sorts each group by strength, collects them into a dictionary, clears matchPFos, and finally re-collects only the most urgent matchPFo from each group to perform secondary filtering.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":163-186",
            "content": "    //1. \u6309\u7167mv\u5206\u7ec4,\u6bcf\u7ec4\u6309pFos\u9ed8\u8ba4\u7684\u5f3a\u5ea6\u6392\u5e8f;\n    NSMutableDictionary *groupDic = [[NSMutableDictionary alloc] init];\n    for (AIMatchFoModel *pFo in inModel.matchPFos) {\n        AIFoNodeBase *fo = [SMGUtils searchNode:pFo.matchFo];\n        //2. \u53d6\u5206\u7ec4;\n        NSMutableArray *itemArr = [groupDic objectForKey:fo.cmvNode_p.algsType];\n        if (!itemArr) itemArr = [[NSMutableArray alloc] init];\n        //3. \u6536\u96c6\u5230\u5206\u7ec4;\n        [itemArr addObject:pFo];\n        [groupDic setObject:itemArr forKey:fo.cmvNode_p.algsType];\n    }\n    //4. \u6e05\u7a7amatchPFos,\u7136\u540e\u91cd\u65b0\u6536\u96c6\u8fc7\u6ee4\u540e\u90e8\u5206;\n    [inModel.matchPFos removeAllObjects];\n    //5. \u628a\u6bcf\u7ec4\u6700\u8feb\u5207\u7684\u4e00\u6761\u6536\u96c6\u8d77\u6765 (\u8fc7\u6ee4\u4ec5\u4fdd\u7559\u6bcf\u7ec4\u6700\u8feb\u5207\u7684\u4e00\u6761);\n    for (NSArray *groupPFos in groupDic.allValues) {\n        NSArray *mostPFo = ARR_SUB(groupPFos, 0, 3);\n        if (ARRISOK(mostPFo)) [inModel.matchPFos addObjectsFromArray:mostPFo];\n    }\n    NSLog(@\"\\n\u65f6\u5e8f\u4e8c\u6b21\u8fc7\u6ee4\u540e\u6761\u6570: \u5269%ld >>>>>>>>>>>>>>>>>>>>>\",inModel.matchPFos.count);\n    for (AIMatchFoModel *item in inModel.matchPFos) NSLog(@\"\\t%ld. %@\",[inModel.matchPFos indexOfObject:item] + 1,Pit2FStr(item.matchFo));"
        },
        {
            "comment": "This code filters the solution scene based on the type of protoScene. It prepares data by fetching abstract or concrete ports depending on the type, then filters out invalid ports based on having the same mvNode and a required number of cansets for specific types.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":187-205",
            "content": "}\n/**\n *  MARK:--------------------Scene\u6c42\u89e3\u8fc7\u6ee4\u5668 (\u53c2\u80032908a-todo2)--------------------\n *  @param type : protoScene\u7684\u7c7b\u578b,i\u65f6\u5411\u62bd\u8c61\u53d6ports,father\u65f6\u5411\u5177\u8c61\u53d6ports;\n *  @version\n *      2023.05.08: BUG_father\u6ca1conCanset\u88ab\u8fc7\u6ee4,\u5bfc\u81f4\u5b83\u7684brother\u5168\u6ca1\u673a\u4f1a\u6fc0\u6d3b (\u6539\u4e3a\u4ec5brother\u65f6\u624d\u8981\u6c42\u5fc5\u987b\u6709cansets\u6307\u5411);\n *      2023.05.15: \u6539\u4e3a\u5f3a\u5ea6\u4e3a\u4e3b,\u5339\u914d\u5ea6\u4e3a\u8f85\u8fdb\u884c\u8fc7\u6ee4 (\u53c2\u800329094-BUG3-\u65b9\u68482);\n */\n+(NSArray*) rSolutionSceneFilter:(AIFoNodeBase*)protoScene type:(SceneType)type {\n    //1. \u6570\u636e\u51c6\u5907: \u5411\u7740isAbs\u65b9\u5411\u53d6\u5f97\u62bd\u5177\u5173\u8054\u573a\u666f;\n    BOOL toAbs = type != SceneTypeFather;\n    NSArray *otherScenePorts = toAbs ? [AINetUtils absPorts_All:protoScene] : [AINetUtils conPorts_All:protoScene];\n    //2. \u6839\u636e\u662f\u5426\u6709conCanset\u8fc7\u6ee4 (\u76ee\u524d\u4ec5\u652f\u6301R\u4efb\u52a1,\u6240\u4ee5\u76f4\u63a5\u7528fo.count\u505atargetIndex) (\u53c2\u800329089-\u89e3\u7b541-\u8865\u5145 & 2908a-todo5);\n    otherScenePorts = [SMGUtils filterArr:otherScenePorts checkValid:^BOOL(AIPort *item) {\n        AIFoNodeBase *fo = [SMGUtils searchNode:item.target_p];//500ms R90 3455\u6b21\n        BOOL mvIdenOK = [fo.cmvNode_p.identifier isEqualToString:protoScene.cmvNode_p.identifier];//mv\u8981\u6c42\u5fc5\u987b\u540c\u533a; //77ms 3455\u6b21\n        BOOL havCansetsOK = type != SceneTypeBrother || ARRISOK([fo getConCansets:fo.count]);//\u975ebrother\u65f6\u8981\u6c42\u5fc5\u987b\u6709cansets; //43ms 3455\u6b21"
        },
        {
            "comment": "This function filters otherScenePorts based on strength and match index dictionary. It first checks if the ID exists and has candidate sets, then filters by strength (mainBlock) and matching index dictionary (subBlock). The resulting ports are returned after conversion to Ports2Pits format.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":206-226",
            "content": "        return mvIdenOK && havCansetsOK; //43ms 3455\u6b21\n    }];\n    //3. \u6839\u636e\u5f3a\u5ea6\u4e3a\u4e3b,\u5339\u914d\u5ea6\u4e3a\u8f85\u8fdb\u884c\u8fc7\u6ee4: \u53d620% & \u81f3\u5c11\u5c1d\u8bd5\u53d63\u6761 (\u53c2\u800329094-BUG3-\u65b9\u68482);\n    otherScenePorts = [self filterTwice:otherScenePorts mainBlock:^double(AIPort *item) {\n        //4. \u6839\u636e\u5f3a\u5ea6,\u8fdb\u884c\u4e3b\u8981\u8fc7\u6ee4 (\u53c2\u800329094-BUG3-\u65b9\u68482);\n        return item.strong.value;//mainBlock 135ms 11540\u6b21\n    } subBlock:^double(AIPort *item) {\n        //5. \u6839\u636eindexDic\u590d\u7528\u5339\u914d\u5ea6\u8fdb\u884c\u8f85\u52a9\u8fc7\u6ee4 (\u53c2\u80032908a-todo2);\n        if (toAbs) {\n            return [AINetUtils getMatchByIndexDic:[protoScene getAbsIndexDic:item.target_p] absFo:item.target_p conFo:protoScene.pointer callerIsAbs:false];//113ms 4038\u6b21\n        }\n        return [AINetUtils getMatchByIndexDic:[protoScene getConIndexDic:item.target_p] absFo:protoScene.pointer conFo:item.target_p callerIsAbs:true];//1436ms 3878\u6b21\n    } radio:0.2f min:4 max:20 debugMode:false];\n    return Ports2Pits(otherScenePorts);\n}\n/**\n *  MARK:--------------------hScene\u6c42\u89e3\u8fc7\u6ee4\u5668 (\u53c2\u80032908a-todo2 & 30127)--------------------\n *  _param type : protoScene\u7684\u7c7b\u578b,i\u65f6\u5411\u62bd\u8c61\u53d6ports,father\u65f6\u5411\u5177\u8c61\u53d6ports;\n *  _param protoTargetIndex : H\u4efb\u52a1\u65f6\u7684targetIndex\u4e0d\u662ffo.count,\u6240\u4ee5\u4f20\u5165\u5176\u5bf9\u5e94\u7684\u503c (\u540e\u53d1\u73b0,\u5176\u5b9e\u5c31\u662fprotoScene.cutIndex+1);"
        },
        {
            "comment": "This code filters the other scene ports based on whether there is a conCanset and supports R tasks. It takes the target index of protoScene, checks if it's an absolute or conditional scene, searches for associated scene ports, and filters them based on their corresponding assScene target index.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":227-245",
            "content": " *  @version\n *      2023.09.09: \u521d\u7248,hDemand\u652f\u6301TCScene (\u53c2\u800330127);\n */\n+(NSArray*) hSolutionSceneFilter:(AISceneModel*)protoScene {\n    //1. \u6570\u636e\u51c6\u5907: \u5411\u7740isAbs\u65b9\u5411\u53d6\u5f97\u62bd\u5177\u5173\u8054\u573a\u666f;\n    NSInteger protoTargetIndex = protoScene.cutIndex + 1;\n    BOOL toAbs = protoScene.type != SceneTypeFather;\n    AIFoNodeBase *sceneFo = [SMGUtils searchNode:protoScene.scene];\n    NSArray *otherScenePorts = toAbs ? [AINetUtils absPorts_All:sceneFo] : [AINetUtils conPorts_All:sceneFo];\n    //2. \u6839\u636e\u662f\u5426\u6709conCanset\u8fc7\u6ee4 (\u76ee\u524d\u4ec5\u652f\u6301R\u4efb\u52a1,\u6240\u4ee5\u76f4\u63a5\u7528fo.count\u505atargetIndex) (\u53c2\u800329089-\u89e3\u7b541-\u8865\u5145 & 2908a-todo5);\n    otherScenePorts = [SMGUtils filterArr:otherScenePorts checkValid:^BOOL(AIPort *item) {\n        //a. \u53d6\u8054\u60f3\u5230\u7684assScene\u5bf9\u5e94\u7684targetIndex;\n        NSDictionary *indexDic = toAbs ? [sceneFo getAbsIndexDic:item.target_p] : [sceneFo getConIndexDic:item.target_p];\n        NSNumber *assSceneTargetIndex = nil;\n        if (toAbs) {\n            assSceneTargetIndex = ARR_INDEX([indexDic allKeysForObject:@(protoTargetIndex)], 0);\n        } else {\n            assSceneTargetIndex = [indexDic objectForKey:@(protoTargetIndex)];"
        },
        {
            "comment": "Code snippet checks for valid scene index based on the given conditions: a. The requested scene must have at least one frame; b. The requested scene must contain corresponding protoTargetIndex frames; c. If the requested scene is not of type \"Brother\", it must have cansets. It then performs a filtering process, prioritizing strength and matching degree to select 20% of the strongest items with at least three tries (referring to 29094-BUG3-\u65b9\u68482). The matching degree is computed by considering only the initial segment of target indices and excluding the protoTargetIndex index.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":246-266",
            "content": "        }\n        //b. \u8981\u6c42\u5fc5\u987b\u6709\u8054\u60f3\u5230\u7684scene\u5fc5\u987b\u5305\u542b\u5bf9\u5e94protoTargetIndex\u7684\u5e27;\n        if (!assSceneTargetIndex) {\n            return false;\n        }\n        //c. \u8981\u6c42\u8054\u60f3\u5230\u7684scene\u5fc5\u987b\u6709cansets;\n        AIFoNodeBase *assScene = [SMGUtils searchNode:item.target_p];//500ms R90 3455\u6b21\n        BOOL havCansetsOK = protoScene.type != SceneTypeBrother || ARRISOK([assScene getConCansets:assSceneTargetIndex.integerValue]);//\u975ebrother\u65f6\u8981\u6c42\u5fc5\u987b\u6709cansets; //43ms 3455\u6b21\n        return havCansetsOK; //43ms 3455\u6b21\n    }];\n    //3. \u6839\u636e\u5f3a\u5ea6\u4e3a\u4e3b,\u5339\u914d\u5ea6\u4e3a\u8f85\u8fdb\u884c\u8fc7\u6ee4: \u53d620% & \u81f3\u5c11\u5c1d\u8bd5\u53d63\u6761 (\u53c2\u800329094-BUG3-\u65b9\u68482);\n    otherScenePorts = [self filterTwice:otherScenePorts mainBlock:^double(AIPort *item) {\n        //4. \u6839\u636e\u5f3a\u5ea6,\u8fdb\u884c\u4e3b\u8981\u8fc7\u6ee4 (\u53c2\u800329094-BUG3-\u65b9\u68482);\n        return item.strong.value;//mainBlock 135ms 11540\u6b21\n    } subBlock:^double(AIPort *item) {\n        //5. \u4ec5\u622a\u51fa\u524d\u6bb5\u53c2\u4e0e\u5339\u914d\u5ea6\u8ba1\u7b97 (\u4e0d\u542btargetIndex\u7684indexDic\u90e8\u5206);\n        NSDictionary *indexDic = toAbs ? [sceneFo getAbsIndexDic:item.target_p] : [sceneFo getConIndexDic:item.target_p];\n        indexDic = [SMGUtils filterDic:indexDic checkValid:^BOOL(NSNumber *key, NSNumber *value) {"
        },
        {
            "comment": "This code snippet filters items based on two criteria: indexDic and the absolute or relative value of a parameter. It uses the AINetUtils function to get the matching index based on the indexDic. The function then applies two different filters based on whether the input is absolute or relative, and returns the filtered list of items. Additionally, there's a private method for calculating the ratio between primary and secondary filters to keep 50% of items after applying both filters.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":267-290",
            "content": "            return (toAbs ? value.integerValue : key.integerValue) < protoTargetIndex;\n        }];\n        //6. \u6839\u636eindexDic\u590d\u7528\u5339\u914d\u5ea6\u8fdb\u884c\u8f85\u52a9\u8fc7\u6ee4 (\u53c2\u80032908a-todo2);\n        if (toAbs) {\n            return [AINetUtils getMatchByIndexDic:indexDic absFo:item.target_p conFo:sceneFo.p callerIsAbs:false];//113ms 4038\u6b21\n        }\n        return [AINetUtils getMatchByIndexDic:indexDic absFo:sceneFo.p conFo:item.target_p callerIsAbs:true];//1436ms 3878\u6b21\n    } radio:0.2f min:4 max:20 debugMode:false];\n    return Ports2Pits(otherScenePorts);\n}\n//MARK:===============================================================\n//MARK:                     < privateMethod >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u540c\u65f6\u7b26\u5408\u4e24\u9879\u8fc7\u6ee4\u5668\u7684\u524dxx% (\u53c2\u800328152-\u65b9\u68483)--------------------\n *  @desc \u516c\u5f0f\u8bf4\u660e:\n *      1. \u8981\u6c42: \u603b\u8fc7\u6ee4\u657020 = \u603b\u657030 - \u7ed3\u679c\u657010;\n *      2. \u4e3b\u8f85\u4efb\u52a1\u529b\u5ea6: \u7b49\u4e8e4:1\u65f6: \u4e3b\u8fc7\u6ee4\u638916\u6761,\u8f85\u8fc7\u6ee4\u63894\u6761 \u5373\u53ef;\n *      3. \u4e3b\u8f85\u8fc7\u6ee4\u6761\u6570: \u4e3b\u8fc7\u6ee4\u540e,\u5269\u4e0b14(30-16)\u6761; \u8f85\u8fc7\u6ee4\u540e\u5269\u4e0b10(14-4)\u6761;\n *      4. \u4e3b\u8f85\u8fc7\u6ee4\u7387: \"\u4e3b\u8fc7\u6ee4\u7387 = \u5269\u4e0b14 / \u603b\u657030\",\"\u8f85\u8fc7\u6ee4\u7387 = \u5269\u4e0b10 / \u5269\u4e0b14\";\n *      5. \u6700\u7ec8\u6210\u529f\u7559\u4e0b\u7ed3\u679c10\u6761;"
        },
        {
            "comment": "This code filters an array twice, using a main and sub block. It takes in an array of objects, two filter blocks, radio value (filter rate), minimum number of results, maximum number of results, and a debug mode flag. The code prepares the data, calculates the result count based on the radio and minimum values, applies the filters twice in a nested fashion, and returns the filtered results.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":291-313",
            "content": " *  @desc \u53ef\u914d\u7f6e\u9879 (\u6ce8:\u6bcf\u9879\u6570\u5b57\u53ef\u8c03):\n *      1. \u7ed3\u679c\u6570: \u8d8a\u5927\u8fd4\u56de\u8d8a\u591a;\n *      2. \u4e3b\u8f85\u4efb\u52a1\u6bd4\u4f8b: \u8d8a\u5927\u4e3b\u8fc7\u6ee4\u5668\u4f5c\u7528\u8d8a\u5927;\n *      3. \u6700\u5c0f\u6761\u6570\u767e\u5206\u6bd4: \u503c\u8d8a\u5c0f\u8d8a\u51c6;\n *  @desc \u73b0\u914d\u7f6e: \u7ed3\u679c\u6570\u4e3a16%,\u4e3b\u8f85\u8fc7\u6ee4\u529b\u5ea620:1,\u5373\u4e3b\u8fc7\u6ee4\u638980%,\u8f85\u518d\u8fc7\u6ee4\u6389\u5269\u4e0b\u768420%;\n *  @param radio : \u8fc7\u6ee4\u7387 (\u4f20\u503c\u8303\u56f40-1),\u8d8a\u5c0f\u8d8a\u7cbe\u51c6,\u4f46\u5269\u4f59\u7ed3\u679c\u8d8a\u5c11,\u53cd\u4e4b\u5176\u6548\u4ea6\u53cd;\n *  @param min : \u6700\u5c0f\u8fd4\u56de\u6761\u6570;\n *\n *  @version\n *      2023.03.06: \u8fc7\u6ee4\u524d20%\u6539\u4e3a35% (\u53c2\u800328152-\u65b9\u68483-todo2);\n *      2023.03.07: \u51cf\u5c11\u8fc7\u6ee4\u7ed3\u679c\u6761\u6570(\u4ece10\u52303),\u907f\u514d\u8fc7\u6ee4\u5668\u4e45\u4e45\u4e0d\u751f\u6548 (\u53c2\u800328152b-todo1);\n *      2023.03.07: \u8fc7\u6ee4\u7387\u6539\u6210\u52a8\u6001\u8ba1\u7b97,\u4f7f\u5176\u6761\u6570\u5c11\u65f6,\u4e24\u4e2a\u8fc7\u6ee4\u5668\u4e5f\u90fd\u80fd\u751f\u6548 (\u53c2\u800328152b-todo2);\n *      2023.03.07: \u4fee\u6539\u4e3b\u8f85\u8fc7\u6ee4\u5668\u4e3a\u5d4c\u5957\u6267\u884c (\u53c2\u800328152b-todo3);\n *      2023.03.07: \u7ed3\u679c\u4fdd\u7559\u6539\u4e3a16%,\u5c06\u4e3b\u8f85\u529b\u5ea6\u8c03\u6574\u4e3a20:1 (\u56e0\u4e3a\u5b9e\u6d4b4:1\u65f6,\u771f\u5b9e\u4e3b\u8fc7\u6ee4\u7387=37%\u5de6\u53f3,\u592a\u9ad8\u4e86);\n *      2023.03.18: \u52a0\u4e0aradio\u53c2\u6570,\u65b9\u4fbf\u5bf9\u6982\u5ff5\u548c\u65f6\u5e8f\u7684\u8fc7\u6ee4\u5668\u5206\u522b\u6307\u5b9a\u4e0d\u540c\u7684\u8fc7\u6ee4\u5ea6 (\u53c2\u800328186-\u65b9\u68481-\u7ed3\u679c);\n *      2023.06.12: \u52a0\u4e0amax\u6761\u4ef6\u4e0a\u9650 (\u907f\u514d\u7ed3\u679c\u8fc7\u591a,\u5bfc\u81f4\u6027\u80fd\u95ee\u9898) (\u53c2\u800330022-\u4f18\u53162);\n */\n+(NSArray*) filterTwice:(NSArray*)protoArr mainBlock:(double(^)(id item))mainBlock subBlock:(double(^)(id item))subBlock radio:(CGFloat)radio min:(NSInteger)min max:(NSInteger)max debugMode:(BOOL)debugMode {\n    //0. \u6570\u636e\u51c6\u5907;\n    if (!ARRISOK(protoArr)) return protoArr;\n    //1. \u6761\u6570 (\u53c2\u8003\u6ce8\u91ca\u516c\u5f0f\u8bf4\u660e-1);\n    NSInteger resultNum = [self getResultNum:protoArr.count radio:radio min:min max:max];"
        },
        {
            "comment": "This code performs a filtering process on an array of data, dividing the task into five steps. It calculates the total number of filters needed based on the remaining items in the array, assigns weights to the primary and secondary filters, determines how many times each filter should be applied, calculates the ratios for each filter, and finally sorts the data using two sorting blocks with nested filter applications.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":315-331",
            "content": "    //2. \u8fc7\u6ee4\u4efb\u52a1\u548c\u529b\u5ea6 (\u53c2\u8003\u6ce8\u91ca\u516c\u5f0f\u8bf4\u660e-2);\n    NSInteger filterNum = protoArr.count - resultNum;               //\u603b\u8fc7\u6ee4\u4efb\u52a1 (\u6bd4\u5982\u517130\u6761,\u526910\u6761,\u8fc7\u6ee4\u4efb\u52a1\u5c31\u662f20\u6761);\n    CGFloat zuFilterForce = 20, fuFilterForce = 1;                  //\u4e3b\u8f85\u4e24\u8fc7\u6ee4\u5668\u7684\u529b\u5ea6\u6743\u91cd (\u4e00\u822c\u4e3b\u529b\u5ea6\u8981\u5927\u4e8e\u8f85\u529b\u5ea6\u591a\u500d);\n    CGFloat totalForce = zuFilterForce + fuFilterForce;             //\u603b\u8fc7\u6ee4\u529b\u91cf\u4efd\u6570 (\u6bd4\u5982: \u4e3b4 + \u8f851 = \u603b\u529b5\u4efd);\n    //3. \u4e3b\u8f85\u8fc7\u6ee4\u6761\u6570 (\u53c2\u8003\u6ce8\u91ca\u516c\u5f0f\u8bf4\u660e-3);\n    CGFloat fuFilterNum = filterNum / totalForce * fuFilterForce;   //\u8f85\u8fc7\u6ee4\u6761\u6570;\n    CGFloat zuFilterNum = filterNum - fuFilterNum;                  //\u4e3b\u8fc7\u6ee4\u6761\u6570;\n    //4. \u4e3b\u8f85\u8fc7\u6ee4\u7387 (\u53c2\u8003\u6ce8\u91ca\u516c\u5f0f\u8bf4\u660e-4);\n    CGFloat zuRate = (protoArr.count - zuFilterNum) / protoArr.count;   //\u4e3b\u8fc7\u6ee4\u7387;\n    CGFloat fuRate = resultNum / (protoArr.count - zuFilterNum);        //\u8f85\u8fc7\u6ee4\u7387;\n    //5. \u4e3b\u4e2d\u8f85,\u5d4c\u5957\u8fc7\u6ee4 (\u53c2\u800328152b-todo3);\n    NSArray *filter1 = ARR_SUB([SMGUtils sortBig2Small:protoArr compareBlock:mainBlock], 0, protoArr.count * zuRate);\n    NSArray *filter2 = ARR_SUB([SMGUtils sortBig2Small:filter1 compareBlock:subBlock], 0, filter1.count * fuRate);\n    if (debugMode) NSLog(@\"\u8fc7\u6ee4\u5668: \u603b%ld\u9700%ld"
        },
        {
            "comment": "1. Prepares the data for filtering.\n2. Calculates the result number based on given radio, min, and max values.\n3. Filters the protoArr using the mainBlock compare method.\n4. Returns the filtered array as a result.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":331-353",
            "content": " \u4e3b:%.2f => \u5269:%ld \u8f85:%.2f => \u5269:%ld\",protoArr.count,resultNum,zuRate,filter1.count,fuRate,filter2.count);\n    //6. \u8fd4\u56de\u7ed3\u679c (\u53c2\u8003\u6ce8\u91ca\u516c\u5f0f\u8bf4\u660e-5);\n    return filter2;\n}\n+(NSArray*) filterOnce:(NSArray*)protoArr mainBlock:(double(^)(id item))mainBlock radio:(CGFloat)radio min:(NSInteger)min max:(NSInteger)max{\n    //0. \u6570\u636e\u51c6\u5907;\n    if (!ARRISOK(protoArr)) return protoArr;\n    NSInteger resultNum = [self getResultNum:protoArr.count radio:radio min:min max:max];\n    CGFloat realRate = (float)resultNum / protoArr.count;       //\u5b9e\u9645\u8fc7\u6ee4\u7387;\n    //2. \u8fc7\u6ee4\u5e76\u8fd4\u56de\u7ed3\u679c;\n    NSArray *filter = ARR_SUB([SMGUtils sortBig2Small:protoArr compareBlock:mainBlock], 0, protoArr.count * realRate);\n    NSLog(@\"\u8fc7\u6ee4\u5668: \u603b%ld\u9700%ld \u4e3b:%.2f => \u5269:%ld\",protoArr.count,resultNum,realRate,filter.count);\n    return filter;\n}\n/**\n *  MARK:--------------------\u7b97\u51fa\u8fc7\u6ee4\u5668\u4fdd\u7559\u7ed3\u679c\u6570--------------------\n */\n+(NSInteger) getResultNum:(NSInteger)protoNum radio:(CGFloat)radio min:(NSInteger)min max:(NSInteger)max {\n    NSInteger resultNum = (NSInteger)(radio * protoNum);  //\u5efa\u8bae\u6761\u6570 (\u5efa\u8bae16%,\u503c\u8d8a\u5c0f\u8d8a\u51c6);"
        },
        {
            "comment": "This code ensures that the result is within a specific range by first limiting it to be between min and max values, then ensuring it's also within the bounds of 0 and protoCount. The function returns this validated result value.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/Util/AIFilter.m\":354-359",
            "content": "    resultNum = MIN(max, MAX(min, resultNum));            //\u7ed3\u679c\u9700 >=min && <=max;\n    resultNum = MIN(protoNum, MAX(0, resultNum));         //\u7ed3\u679c\u9700 >=0 && <= protoCount;\n    return resultNum;\n}\n@end"
        }
    ]
}