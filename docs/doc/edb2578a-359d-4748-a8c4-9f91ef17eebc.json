{
    "summary": "The `orderSames` function creates abstract relationships between Fo nodes, updates jMax in a dictionary, and logs results. It also compares responsibility ratios using machine learning algorithms and analogy, mapping with scene objects and enhancing eff values.",
    "details": [
        {
            "comment": "This code is part of the AIAnalogy class implementation. It contains a function called `orderSames` which builds the `absFo` for order analogies by finding common elements between two sequences and also handling continuous signals. This information is then used in functions like `analogy_Feedback_Same`, `analogyInner`, and `reasonRethink`. The code also includes some notes about preventing duplication and using blocks to abstract multiple sames.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":0-34",
            "content": "//\n//  AIAnalogy.m\n//  SMG_NothingIsAll\n//\n//  Created by jia on 2019/3/20.\n//  Copyright \u00a9 2019\u5e74 XiaoGang. All rights reserved.\n//\n#import \"AIAnalogy.h\"\n#import \"AINetAbsCMVUtil.h\"\n@implementation AIAnalogy\n//MARK:===============================================================\n//MARK:                     < \u5916\u7c7b\u6bd4\u65f6\u5e8f >\n//MARK:===============================================================\n/**\n *  MARK:--------------------fo\u5916\u7c7b\u6bd4 (\u627e\u76f8\u540c\u7b97\u6cd5)--------------------\n *  @desc                   : orderSames\u7528\u4e8e\u6784\u5efaabsFo\n *  @callers\n *      1. analogy_Feedback_Same()  : \u540c\u5411\u53cd\u9988\u7c7b\u6bd4\n *      2. analogyInner()           : \u5185\u7c7b\u6bd4\n *      3. reasonRethink()          : \u53cd\u7701\u7c7b\u6bd4\n *\n *  1. \u8fde\u7eed\u4fe1\u53f7\u4e2d,\u627e\u91cd\u590d;(\u8fde\u7eed\u4e5f\u662f\u62c6\u5206,\u591a\u4e8b\u52a1\u5904\u7406\u7684)\n *  2. \u4e24\u6761\u4fe1\u606f\u4e2d,\u627e\u4ea4\u96c6;\n *  3. \u5728\u8fde\u7eed\u4fe1\u53f7\u7684\u5904\u7406\u4e2d,\u5b9e\u65f6\u5c06\u62c6\u5206\u5355\u4fe1\u53f7\u5b58\u50a8\u5230\u5185\u5b58\u533a,\u5e76\u63d0\u4f9b\u53ef\u68c0\u7d22\u7b49,\u5176\u5f62\u6001\u4e0e\u6700\u7ec8\u5b58\u786c\u76d8\u662f\u4e00\u81f4\u7684;\n *  4. \u7c7b\u6bd4\u5904\u7406(\u74dc\u662f\u74dc)\n *  \u6ce8: \u7c7b\u6bd4\u7684\u5904\u7406,\u662f\u8db3\u591f\u7ec6\u5316\u7684,\u5bf9\u601d\u7ef4\u6bcf\u4e2a\u4fe1\u53f7\u4f5c\u7c7b\u6bd4\u64cd\u4f5c;(\u800c\u5c06\u7c7b\u6bd4\u5230\u7684\u6700\u57fa\u672c\u7684\u7ed3\u679c,\u8f93\u51fa\u7ed9thinking,\u4ee5\u4f9b\u4e3a\u6784\u5efa\u7f51\u7edc\u7684\u4f9d\u636e,\u6700\u7ec8\u662f\u4ee5\u7f51\u7edc\u4e3a\u76ee\u7684\u7684)\n *  \u6ce8: \u968f\u540e\u53ef\u4ee5\u7531\u4e00\u4e2asames\u6539\u4e3a\u591a\u4e2asames\u5e76\u5b9e\u65f6\u4f7f\u7528block\u62bd\u8c61 (\u5e76\u6d88\u8017energy);\n *  _param noRepeatArea_ps : \u7c7b\u6bd4\u7ed3\u679cabsFo\u7684\u9632\u91cd\u8303\u56f4 (\u9ed8\u8ba4\u4f20nil\u65f6,\u4f1a\u5168\u5c40\u9632\u91cd);\n *\n *  @version\n *      20200215: \u6709\u5e8f\u5916\u7c7b\u6bd4: \u5c06forin\u5faa\u73affo\u548cassFo\u6539\u4e3a\u53cd\u5e8f,\u5e76\u8bb0\u5f55\u4e0a\u6b21\u7c7b\u6bd4\u4f4d\u7f6ejMax (\u56e0\u51fa\u73b0\u4e86[\u679c,\u679c,\u5403,\u5403]\u8fd9\u6837\u7684\u5f02\u5e38\u65f6\u5e8f) \u53c2\u8003n18p11;"
        },
        {
            "comment": "This code defines two methods for performing analogy outside with given prototype and associated fo nodes, and type. It includes functionality to support outside analogy, shared points abstraction, mapping protoFo/assFo indexDic, and noRepeatArea_ps.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":35-49",
            "content": " *      20200831: \u652f\u6301\u53cd\u7701\u5916\u7c7b\u6bd4,\u5f97\u51fa\u66f4\u786e\u5207\u7684ATSub\u539f\u56e0,\u53c2\u8003:20205-\u6b65\u9aa44;\n *      20201203: \u4fee\u590d21175BUG (\u56e0createAbsAlgBlock\u5fd8\u8bb0\u8c03\u7528,\u5bfc\u81f4absAlg\u548cglAlg\u95f4\u672a\u5173\u8054) (\u53c2\u800321115);\n *      20210819: \u4fee\u590d\u957f1\u548c\u957f2\u7c7b\u6bd4\u65f6,\u7c7b\u6bd4\u51fa\u957f2\u7684BUG (\u53c2\u800323221-BUG2);\n *      20210926: \u4fee\u590dglFo\u5916\u7c7b\u6bd4\u65f6\u975e\u672b\u4f4dalg\u7c7b\u6bd4\u6784\u5efaabsAlg\u65f6,\u4e5f\u4f7f\u7528\u4e86GLType\u7684\u95ee\u9898 (\u53c2\u800324022-BUG1);\n *      20221028: \u7528mIsC\u5224\u65ad\u66ff\u4ee3sameValue_ps (\u53c2\u800327153-todo4);\n *      20230322: \u6253\u5f00\u5916\u7c7b\u6bd4,\u652f\u6301(\u6839\u636e\u76f8\u8fd1\u5ea6\u5c06\u4e3b\u8981\u8d23\u4efb\u7684\u7801\u62bd\u8c61\u6389)\u5171\u540c\u70b9\u62bd\u8c61 (\u53c2\u800329025-11);\n *      20230327: \u652f\u6301\u5f97\u51faprotoFo/assFo \u4e0e absFo\u7684indexDic\u6620\u5c04 (\u53c2\u800329032-todo1.2);\n */\n+(AINetAbsFoNode*) analogyOutside:(AIFoNodeBase*)protoFo assFo:(AIFoNodeBase*)assFo type:(AnalogyType)type {\n    return [self analogyOutside:protoFo assFo:assFo type:type noRepeatArea_ps:nil];\n}\n+(AINetAbsFoNode*) analogyOutside:(AIFoNodeBase*)protoFo assFo:(AIFoNodeBase*)assFo type:(AnalogyType)type noRepeatArea_ps:(NSArray*)noRepeatArea_ps {\n    //1. \u7c7b\u6bd4orders\u7684\u89c4\u5f8b\n    if (Log4OutAna) NSLog(@\"\\n----------- \u5916\u7c7b\u6bd4(%@) -----------\\nfo:%@ \\nassFo:%@\",ATType2Str(type),Fo2FStr(protoFo),Fo2FStr(assFo));\n    NSMutableArray *orderSames = [[NSMutableArray alloc] init];"
        },
        {
            "comment": "This code collects the mapping between proto and ass, performs ordered comparison for analogy learning, checks if B is 1 level of abstraction, creates an abstract representation of matching algorithms, updates jMax and stores it in a dictionary.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":50-70",
            "content": "    NSMutableDictionary *protoAssIndexDic = [NSMutableDictionary new];//\u6536\u96c6proto\u548cass\u7684\u6620\u5c04;\n    if (protoFo && assFo) {\n        //2. \u5916\u7c7b\u6bd4\u6709\u5e8f\u8fdb\u884c (\u8bb0\u5f55jMax & \u53cd\u5e8f)\n        NSInteger jMax = assFo.count - 1;\n        for (NSInteger i = protoFo.count - 1; i >= 0; i--) {\n            for (NSInteger j = jMax; j >= 0; j--) {\n                AIKVPointer *protoA_p = protoFo.content_ps[i];\n                AIKVPointer *assA_p = assFo.content_ps[j];\n                //3. B\u6e90\u4e8ematchFo,\u6b64\u5904\u53ea\u5224\u65adB\u662f1\u5c42\u62bd\u8c61 (\u53c2\u800327161-\u8c03\u8bd51&\u8c03\u8bd52);\n                //\u6b64\u5904proto\u62bd\u8c61\u4ec5\u6307\u5411\u521a\u8bc6\u522b\u7684matchAlgs,\u6240\u4ee5\u4e0econtains\u7b49\u6548;\n                BOOL mIsC = [TOUtils mIsC_1:protoA_p c:assA_p];\n                if (Log4OutAna) NSLog(@\"proto\u7684\u7b2c%ld: A%ld \u7c7b\u6bd4 ass\u7684\u7b2c%ld: A%ld (%@)\",i,protoA_p.pointerId,j,assA_p.pointerId,mIsC?@\"\u6210\u529f\":@\"\u5931\u8d25\");\n                if (mIsC) {\n                    //4. \u5373\u4f7fmIsC\u5339\u914d,\u4e5f\u8981\u8fdb\u884c\u5171\u540c\u70b9\u62bd\u8c61 (\u53c2\u800329025-11);\n                    AIAlgNodeBase *absA = [self analogyAlg:protoA_p assA:assA_p];\n                    //5. \u6536\u96c6\u5e76\u66f4\u65b0jMax;\n                    [protoAssIndexDic setObject:@(i) forKey:@(j)];"
        },
        {
            "comment": "This code appears to be part of a larger program related to analogy construction and learning. It generates dictionaries for absolute indexes, builds an outside analogy, and adjusts the direction strength index based on similarities between abstract and concrete elements.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":71-96",
            "content": "                    [orderSames insertObject:absA.pointer atIndex:0];\n                    jMax = j - 1;\n                    break;\n                }\n            }\n        }\n    }\n    //6. \u751f\u6210protoIndexDic \u548c assIndexDic  (\u53c2\u800329032-todo1.2);\n    NSDictionary *assAbsIndexDic = [AINetUtils getIndexDic4AnalogyAbsFo:protoAssIndexDic.allKeys];\n    NSDictionary *protoAbsIndexDic = [AINetUtils getIndexDic4AnalogyAbsFo:protoAssIndexDic.allValues];\n    //7. \u5916\u7c7b\u6bd4\u6784\u5efa\n    return [self analogyOutside_Creater:orderSames protoFo:protoFo assFo:assFo type:type protoIndexDic:protoAbsIndexDic assIndexDic:assAbsIndexDic noRepeatArea_ps:noRepeatArea_ps];\n}\n/**\n *  MARK:--------------------\u5916\u7c7b\u6bd4\u7684\u6784\u5efa\u5668--------------------\n *  1. \u6784\u5efaabsFo\n *  2. \u6784\u5efaabsCmv\n *  @todo\n *      20200416 - TODO_NEXT_VERSION:\u65b9\u6cd5\u4e2dabsFo\u662f\u9632\u91cd\u7684,\u5982\u679cabsFo\u5e76\u975e\u65b0\u6784\u5efa,\u800c\u53c8\u4e3a\u5176\u6784\u5efa\u4e86absMv,\u5219\u4f1a\u6709\u591a\u4e2amv\u6307\u5411\u540c\u4e00\u4e2afo\u7684\u95ee\u9898;\n *  @version\n *      2020.07.22: \u5728\u5916\u7c7b\u6bd4\u65e0\u9700\u6784\u5efa\u65f6 (\u5373\u5177\u8c61\u548c\u62bd\u8c61\u4e00\u81f4\u65f6),\u5176\u65b9\u5411\u7d22\u5f15\u5f3a\u5ea6+1;\n *      2021.08.10: \u5728RFos\u7684\u518d\u62bd\u8c61\u8c03\u7528\u65f6,\u6709\u53ef\u80fd\u5c06\u9632\u91cd\u7684\u5e26mvDeltaTime\u7684\u503c\u91cd\u7f6e\u4e3a0\u7684BUG (\u53c2\u800323212-\u95ee\u98982);\n *      2021.09.23: \u6784\u5efafo\u65f6,\u65b0\u589etype\u53c2\u6570,\u5e9f\u5f03\u539ffoDS(typeStr)\u7684\u505a\u6cd5 (\u53c2\u800324019-\u65f6\u5e8f\u90e8\u5206);"
        },
        {
            "comment": "The code creates an abstract relationship between two Fo nodes based on a set of orderSames. It checks if the assFo is already an abstract relationship and if so, directly associates it with the protoFo.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":97-111",
            "content": " *      2021.09.26: \u4ec5\u6784\u5efaglFo\u65f6\u624d\u4ececonNodes\u53d6at&ds\u503c,\u907f\u514dSFo\u4e5f\u6709\u503c\u7684\u95ee\u9898 (\u53c2\u800324022-BUG2);\n *      2021.09.28: ATSame\u548cATDiff\u4e24\u4e2atype\u662f\u63cf\u8ff0\u662f\u5426\u5305\u542bcmv\u6307\u5411\u7684,\u6539\u4e3a\u4f20ATDefault\u8fc7\u6765 (\u53c2\u800324022-BUG5);\n *      2023.07.28: \u628amvDeltaTime\u6539\u6210\u504f\u79fb\u4fee\u6b63\u65b9\u5f0f (\u53c2\u800330087-\u5206\u67901);\n */\n+(AINetAbsFoNode*)analogyOutside_Creater:(NSArray*)orderSames protoFo:(AIFoNodeBase*)protoFo assFo:(AIFoNodeBase*)assFo type:(AnalogyType)type protoIndexDic:(NSDictionary*)protoIndexDic assIndexDic:(NSDictionary*)assIndexDic noRepeatArea_ps:(NSArray*)noRepeatArea_ps{\n    //2. \u6570\u636e\u68c0\u67e5;\n    AINetAbsFoNode *result = nil;\n    if (ARRISOK(orderSames) && ISOK(protoFo, AIFoNodeBase.class) && ISOK(assFo, AIFoNodeBase.class)) {\n        //3. fo\u548cassFo\u672c\u6765\u5c31\u662f\u62bd\u8c61\u5173\u7cfb\u65f6_\u76f4\u63a5\u5173\u8054\u5373\u53ef;\n        BOOL samesEqualAssFo = orderSames.count == assFo.count && [SMGUtils containsSub_ps:orderSames parent_ps:assFo.content_ps];\n        BOOL jumpForAbsAlreadyHav = (ISOK(assFo, AINetAbsFoNode.class) && samesEqualAssFo);\n        if (jumpForAbsAlreadyHav) {\n            result = (AINetAbsFoNode*)assFo;\n            [AINetUtils relateFoAbs:result conNodes:@[protoFo] isNew:false];"
        },
        {
            "comment": "This code creates an abstract concept node (absFoNode) and calculates its total strength. It checks the reference ports for a result pointer, sets the direction reference based on a specified node, or retrieves foDifStrong from two nodes. It then constructs absFoNode with given parameters, computes the total strength considering accumulated related strengths.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":112-128",
            "content": "            [AINetUtils insertRefPorts_AllFoNode:result.pointer order_ps:result.content_ps ps:result.content_ps];\n            if (result.cmvNode_p) [theNet setMvNodeToDirectionReference:[SMGUtils searchNode:result.cmvNode_p] difStrong:1];\n        }else{\n            //4. \u53d6foDifStrong\n            NSInteger foDifStrong = 1;\n            AICMVNodeBase *foMv = [SMGUtils searchNode:protoFo.cmvNode_p];\n            AICMVNodeBase *assMv = [SMGUtils searchNode:assFo.cmvNode_p];\n            if (foMv && assMv) {\n                NSArray *conMvs = [SMGUtils searchNodes:@[protoFo.cmvNode_p,assFo.cmvNode_p]];\n                NSInteger absUrgentTo = [AINetAbsCMVUtil getAbsUrgentTo:conMvs];\n                foDifStrong = absUrgentTo;\n            }\n            //5. \u6784\u5efaabsFoNode (\u5f53GL\u65f6,\u4f20\u5165at&ds);\n            result = [theNet createAbsFo_NoRepeat:orderSames protoFo:protoFo assFo:assFo difStrong:foDifStrong type:type protoIndexDic:protoIndexDic assIndexDic:assIndexDic outConAbsIsRelate:nil noRepeatArea_ps:noRepeatArea_ps];\n            //6. \u7b97\u51fa\u5177\u8c61\u603b\u5f3a\u5ea6,\u5176\u548c\u5df2\u7ecf\u662f\u7d2f\u8ba1\u4e86\u6b64\u6b21\u7c7b\u6bd4\u7684\u65b0\u5173\u8054\u5f3a\u5ea6 (\u53c2\u800330087-todo6);"
        },
        {
            "comment": "This code calculates the average mvDeltaTime between two Fo (Focus of Attention) objects, protoFo and assFo, adjusts the result's mvDeltaTime accordingly, and checks if a new AIAbsCMVNode needs to be created. The sum of strong values from connected ports is used in these calculations.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":129-145",
            "content": "            NSArray *conPorts = [AINetUtils conPorts_All:result];\n            NSInteger sumStrong = 0;\n            for (AIPort *item in conPorts) sumStrong += item.strong.value;\n            [AITest test30:sumStrong];\n            CGFloat frontMvDeltaTime4Log = result.mvDeltaTime;\n            //6.1. \u5c06protoFo\u7684mvDeltaTime\u504f\u79fb\u91cf\u8ba1\u5165 (\u53c2\u800330087-todo5&6);\n            result.mvDeltaTime += (protoFo.mvDeltaTime - result.mvDeltaTime) / (sumStrong - 1);\n            //6.2. \u5c06assFo\u7684mvDeltaTime\u504f\u79fb\u91cf\u8ba1\u5165 (\u53c2\u800330087-todo5&6);\n            result.mvDeltaTime += (assFo.mvDeltaTime - result.mvDeltaTime) / sumStrong;\n            NSLog(@\"\u504f\u79fbmvDeltaTime (\u4ece%.2f\u5230%.2f) (\u603b\u5f3a\u5ea6:%ld con1:%.2f con2:%.2f) \",frontMvDeltaTime4Log,result.mvDeltaTime,sumStrong,protoFo.mvDeltaTime,assFo.mvDeltaTime);\n            //6. createAbsCmvNode (\u5f53\u6b63\u5411\u7c7b\u6bd4,\u4e14result\u6ca1\u6709cmv\u6307\u5411\u65f6);\n            if (protoFo.cmvNode_p && assMv && !result.cmvNode_p) {\n                AIAbsCMVNode *resultMv = [theNet createAbsCMVNode_Outside:nil aMv_p:protoFo.cmvNode_p bMv_p:assMv.pointer];\n                [AINetUtils relateFo:result mv:resultMv];//cmv\u6a21\u578b\u8fde\u63a5;"
        },
        {
            "comment": "This code is filtering out concept analogies with low similarity between protoA and assA, applicable only when they have abstract relations. It prepares data by searching nodes, initializes match models, and logs the final results for debugging.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":146-168",
            "content": "            }\n        }\n    }\n    //\u8c03\u8bd5\u77ed\u65f6\u5e8f; (\u5148\u4ec5\u6253\u5916\u7c7b\u6bd4\u65e5\u5fd7);\n    NSInteger foStrong = [AINetUtils getStrong:result atConNode:protoFo type:type];\n    NSInteger assFoStrong = [AINetUtils getStrong:result atConNode:assFo type:type];\n    NSLog(@\"1. \u65b0proto: %@\\n2. \u4e0eass: %@ \\n3. \u5916\u7c7b\u6bd4\u6784\u5efa\u65f6\u5e8f: %@->{%@} from: (protoFo(%ld):assFo(%ld))\",Fo2FStr(protoFo),Fo2FStr(assFo),Fo2FStr(result),Mvp2Str(result.cmvNode_p),foStrong,assFoStrong);\n    return result;\n}\n/**\n *  MARK:--------------------\u6982\u5ff5\u7c7b\u6bd4--------------------\n *  @desc \u6982\u5ff5\u7c7b\u6bd4: \u5c06\u76f8\u8fd1\u5ea6\u4f4e\u7684(\u8d1f\u4e3b\u8981\u8d23\u4efb\u7684)\u8fc7\u6ee4\u6389 (\u53c2\u800329025-12);\n *        \u4f5c\u7528\u8303\u56f4: \u4ec5\u9002\u7528\u4e8eprotoA\u548cassA\u6709\u62bd\u5177\u8c61\u5173\u7cfb\u65f6\u7684\u6982\u5ff5\u7c7b\u6bd4;\n *  @version\n *      2023.05.10: \u4fee\u590d\u6b64\u5904\u62bd\u5177\u8c61\u5339\u914d\u5ea6\u672a\u50a8\u5b58,\u5bfc\u81f4\u590d\u7528\u65f6\u53d6\u4e0d\u5230\u7684\u95ee\u9898 (\u53c2\u800329091);\n */\n+(AIAlgNodeBase*) analogyAlg:(AIKVPointer*)protoA_p assA:(AIKVPointer*)assA_p {\n    //1. \u6570\u636e\u51c6\u5907;\n    AIAlgNodeBase *protoA = [SMGUtils searchNode:protoA_p];\n    AIAlgNodeBase *assA = [SMGUtils searchNode:assA_p];\n    NSMutableArray *sameValue_ps = [[NSMutableArray alloc] init];\n    AIMatchAlgModel *protoAbsModel4MatchValue = [[AIMatchAlgModel alloc] init];//\u6b64\u6a21\u578b\u4ec5\u7528\u4e8e\u6536\u96c6proto\u548cabs\u7684\u76f8\u8fd1\u5ea6,\u7528\u4e8e\u8ba1\u7b97matchValue;"
        },
        {
            "comment": "This code is calculating the responsibility ratio of a current code by comparing it with another one (protoA and assA). It determines if they are in the same area and have similar algorithms. Then, it calculates their match values and computes the responsibility ratio based on these values and missing parts.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":170-183",
            "content": "    //2. \u5206\u522b\u5bf9protoA\u548cassA\u7684\u7a00\u758f\u7801\u8fdb\u884c\u5bf9\u6bd4;\n    for (AIKVPointer *protoV_p in protoA.content_ps) {\n        for (AIKVPointer *assV_p in assA.content_ps) {\n            //3. \u4e8c\u8005\u540c\u533a\u65f6;\n            if ([protoV_p.dataSource isEqualToString:assV_p.dataSource] && [protoV_p.algsType isEqualToString:assV_p.algsType]) {\n                //4. \u4e8c\u8005\u76f8\u4f3c\u5ea6\u8f83\u9ad8\u65f6 (\u8ba1\u7b97\u5f53\u524d\u7801\u7684\u8d23\u4efb\u6bd4\u4f8b: \u6bd4\u5982:1*0.8*0.7\u65f6,\u5f53\u524d\u7801=0.7\u65f6,\u5b83\u7684\u8d23\u4efb\u6bd4\u4f8b=(1-0.7)/(1-0.8 + 1-0.7)=60%) (\u53c2\u800329025-13);\n                CGFloat algMatchValue = [protoA getAbsMatchValue:assA_p];\n                CGFloat valueMatchValue = [AIAnalyst compareCansetValue:protoV_p protoValue:assV_p vInfo:nil];\n                CGFloat otherValueMatchValue = valueMatchValue > 0 ? algMatchValue / valueMatchValue : 1;   //\u522b\u7684\u7801\u76f8\u4e58\u662f0.xx;\n                CGFloat otherQueKou = 1 - otherValueMatchValue;                                             //\u522b\u7684\u7801\u7f3a\u53e3;\n                CGFloat curQueKou = 1 - valueMatchValue;                                                    //\u5f53\u524d\u7801\u7f3a\u53e3;\n                CGFloat sumQueKou = otherQueKou + curQueKou;                                                //\u603b\u7f3a\u53e3;"
        },
        {
            "comment": "The code calculates the current responsibility ratio based on the sum of QueKou values. If it's below 50%, it adds a value to sameValue_ps and increments nearCount and sumNear for protoAbsModel4MatchValue. Otherwise, it logs the difference between A and V codes along with their pointer IDs. It then builds an abstract concept from similar values and updates its match value.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":184-208",
            "content": "                CGFloat curRate = sumQueKou > 0 ? curQueKou / sumQueKou : 0;                                //\u7b97\u51fa\u5f53\u524d\u7801\u8d23\u4efb\u6bd4\u4f8b;\n                //5. \u5f53\u524d\u7801\u8d23\u4efb<50%\u65f6 (\u6b21\u8981\u8d23\u4efb\u65f6,\u514d\u8d23);\n                if (curRate < 0.5) {\n                    [sameValue_ps addObject:assV_p];\n                    //6. \u76f8\u8fd1\u5ea6\u4e2a\u6570nearCount & \u76f8\u8fd1\u5ea6sumNear\n                    protoAbsModel4MatchValue.nearCount++;\n                    protoAbsModel4MatchValue.sumNear *= valueMatchValue;\n                } else {\n                    NSLog(@\"> \u5f53\u524dA%ld<%@>\u6bd4A%ld<%@>\u7684\u7f3a\u53e3:%.2f / \u603b\u7f3a\u53e3%.2f = \u5f53\u524d\u8d23\u4efb%.2f\",(long)protoA_p.pointerId,Pit2FStr(protoV_p),(long)assA_p.pointerId,Pit2FStr(assV_p),curQueKou,sumQueKou,curRate);\n                }\n                //6. break\u7ee7\u7eed\u5224\u65adproto\u7684\u4e0b\u4e2aV\u7801;\n                break;\n            }\n        }\n    }\n    //7. \u5c06\u76f8\u8fd1\u5ea6\u5584\u53ef\u7684\u6784\u5efa\u6210\u62bd\u8c61\u6982\u5ff5\u8fd4\u56de;\n    [AITest test29:protoA assA:assA];\n    AIAbsAlgNode *absA = [theNet createAbsAlg_NoRepeat:sameValue_ps conAlgs:@[protoA,assA]];\n    //8. \u5c06\u62bd\u8c61\u6982\u5ff5\u4e0e\u5177\u8c61\u7684\u5339\u914d\u5ea6\u5b58\u4e0b\u6765 (\u53c2\u800329091BUG);\n    [protoA updateMatchValue:absA matchValue:protoAbsModel4MatchValue.matchValue];"
        },
        {
            "comment": "This function returns a net analogy node based on the canset comparison. It checks if the switch for this type of analogy is enabled, and then calculates and returns the new analogy net effect strong. This function has undergone several updates over time, including support for deriving newCansetFo/oldCansetFo indexDic mapping, disabling canset comparison, and adjusting EFF+1 based on transfer completion status. It also fixes an issue with generating a sorted list of absFo sequences due to the unordered keys in dic. Finally, this function has been deprecated.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":209-228",
            "content": "    [assA updateMatchValue:absA matchValue:1];\n    return absA;\n}\n/**\n *  MARK:--------------------Canset\u7c7b\u6bd4 (\u53c2\u800329025-24 & 29027-\u65b9\u68483)--------------------\n *  @version\n *      2023.03.27: \u652f\u6301\u5f97\u51fanewCansetFo/oldCansetFo \u4e0e absCansetFo\u7684indexDic\u6620\u5c04 (\u53c2\u800329032-todo1.1);\n *      2023.04.07: \u5173\u95edCanset\u7c7b\u6bd4 (\u53c2\u800329059-\u6539\u52a8);\n *      2023.04.10: \u573a\u666f\u5305\u542b\u5e27\u7684\u7c7b\u6bd4\u7528mIsC\u5224\u65ad\u6210\u7acb\u540e,\u76f4\u63a5\u91c7\u7528absAlg (\u53c2\u800329067-todo1.1);\n *      2023.04.19: \u53d6\u6d88EFF+1,\u56e0\u4e3a\u8fc1\u79fb\u5b8c\u6210\u4e0d\u8868\u793a\u5df2\u6b63\u5411\u53d1\u751f (\u53c2\u800329069-todo12.1);\n *      2023.04.29: \u5f97\u51faabsCanset\u548cscene\u7684indexDic (\u53c2\u800329076-todo2);\n *      2023.09.01: \u8fc1\u79fb\u5b8c\u6210\u65f6EFF\u4e0d\u53d8(\u53c2\u6570\u4f20ES_Default),\u4f46newCanset\u6709\u7528\u65f6+1,\u65e0\u7528\u65f6-1 (\u53c2\u800330124-todo2 & todo3);\n *      2023.09.03: \u4fee\u590ddic.keys\u65e0\u5e8f\u4f1a\u5bfc\u81f4\u6b64\u5904\u751f\u6210\u7684absFo\u5e8f\u5217\u4e5f\u9519\u4e71\u7684\u95ee\u9898;\n *      2023.10.26: \u5e9f\u5f03canset\u7c7b\u6bd4 (\u53c2\u80033014c-todo2);\n */\n//+(AINetAbsFoNode*) analogyCansetFo:(NSDictionary*)indexDic newCanset:(AIFoNodeBase*)newCanset oldCanset:(AIFoNodeBase*)oldCanset sceneFo:(AIFoNodeBase*)sceneFo es:(EffectStatus)es {\n//    //1. \u7c7b\u6bd4orders\u7684\u89c4\u5f8b\n//    if (!Switch4AnalogyCansetFo) return nil;\n//    AIEffectStrong *newEffStrong = [sceneFo getEffectStrong:sceneFo.count solutionFo:newCanset.pointer];"
        },
        {
            "comment": "This code is comparing a new and old set of data by mapping them using an index dictionary. It logs the before and after sets, and then iterates through the keys in sorted order to compare the corresponding indices between the two sets. The sorted keys are obtained from the index dictionary's allKeys property. For each key, it extracts the old and new indices from the dictionary, retrieves the corresponding AIKVPointer objects from the content_ps arrays of the old and new Cansets respectively.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":229-243",
            "content": "//    AIEffectStrong *oldEffStrong = [sceneFo getEffectStrong:sceneFo.count solutionFo:oldCanset.pointer];\n//    if (Log4OutCansetAna) NSLog(@\"\\n----------- Canset\u7c7b\u6bd4 -----------\\nnew:%@ SP:%@ EFF:%@ \\nold:%@ SP:%@ EFF:%@\",\n//                                Fo2FStr(newCanset),CLEANSTR(newCanset.spDic),CLEANSTR(newEffStrong),\n//                                Fo2FStr(oldCanset),CLEANSTR(oldCanset.spDic),CLEANSTR(oldEffStrong));\n//    NSMutableArray *orderSames = [[NSMutableArray alloc] init];\n//\n//    //2. \u6839\u636e\u65b0\u65e7\u7684\u6620\u5c04indexDic\u5206\u522b\u8fdb\u884c\u6982\u5ff5\u7c7b\u6bd4 (\u53c2\u800329025-24a);\n//    NSArray *allKeys = [SMGUtils sortSmall2Big:indexDic.allKeys compareBlock:^double(NSNumber *obj) {\n//        return obj.doubleValue;\n//    }];\n//    for (NSNumber *key in allKeys) {\n//        NSInteger oldIndex = key.integerValue;\n//        NSInteger newIndex = NUMTOOK([indexDic objectForKey:key]).integerValue;\n//        AIKVPointer *oldAlg_p = ARR_INDEX(oldCanset.content_ps, oldIndex);\n//        AIKVPointer *newAlg_p = ARR_INDEX(newCanset.content_ps, newIndex);"
        },
        {
            "comment": "This code is part of a machine learning algorithm that uses analogy to find relationships between data points. It creates an abstract concept (absA) by comparing two input nodes (oldAlg and newAlg). The code then adds the newly created absA to the orderSames list, which holds all the abstract concepts. The code also collects newIndexDic and oldIndexDic for further processing.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":244-265",
            "content": "//\n//        //3. mIsC\u6210\u7acb\u65f6,\u76f4\u63a5\u6536\u96c6oldA (\u5373absAlg) (\u53c2\u800329067-todo1.1);\n//        //AIAlgNodeBase *oldAlg = [SMGUtils searchNode:oldAlg_p];\n//        //AIAlgNodeBase *newAlg = [SMGUtils searchNode:newAlg_p];\n//        //if ([TOUtils mIsC_1:newAlg_p c:oldAlg_p]) {\n//        //    [orderSames addObject:oldAlg_p];\n//        //} else {\n//        //    //4. \u76f4\u63a5\u6784\u5efa\u7a7a\u6982\u5ff5 (\u53c2\u800329027-\u65b9\u68483);\n//        //    //4. 2023.04.11: \u540e\u5e9f\u5f03,\u540e\u53c8\u542f\u7528 (\u53c2\u800329068-todo1);\n//        //    AIAlgNodeBase *absA = [theNet createEmptyAlg_NoRepeat:@[oldAlg,newAlg]];\n//        //\n//        //    //5. \u6536\u96c6;\n//        //    [orderSames addObject:absA.pointer];\n//        //}\n//        //2023.10.17: \u6539\u4e3a\u53ea\u8981indexDic\u7684\u90fd\u7c7b\u6bd4\u4e0b (\u73b0\u5728\u7684indexDic\u4e2d\u5fc5\u7136\u90fd\u662fmIsC\u5173\u7cfb) (\u53c2\u800330148-todo1.2);\n//        AIAlgNodeBase *absA = [AIAnalogy analogyAlg:newAlg_p assA:oldAlg_p];\n//        [orderSames addObject:absA.pointer];\n//    }\n//\n//    //6. \u53d6\u5f97newIndexDic\u548coldIndexDic (\u53c2\u800329032-todo1.1);\n//    NSDictionary *newIndexDic = [AINetUtils getIndexDic4AnalogyAbsFo:indexDic.allValues];\n//    NSDictionary *oldIndexDic = [AINetUtils getIndexDic4AnalogyAbsFo:indexDic.allKeys];"
        },
        {
            "comment": "Creates an abstract comparison using outclass analogy, adds it to the scene FO, and derives a mapping between the abstract FO and the scene FO.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":266-281",
            "content": "//\n//    //7. \u5916\u7c7b\u6bd4\u6784\u5efa\n//    BOOL outConAbsIsRelate = true;\n//    AINetAbsFoNode *absFo = [theNet createAbsFo_NoRepeat:orderSames protoFo:newCanset assFo:oldCanset difStrong:1 type:ATDefault protoIndexDic:newIndexDic assIndexDic:oldIndexDic outConAbsIsRelate:&outConAbsIsRelate];\n//\n//    //8. \u5c06\u62bd\u8c61Canset\u6302\u5230sceneFo\u4e0b;\n//    BOOL updateCansetSuccess = [sceneFo updateConCanset:absFo.pointer targetIndex:sceneFo.count];\n//    if (updateCansetSuccess) {\n//        //9. \u6839\u636escene\u4e0eoldCanset\u7684\u6620\u5c04 \u4e0e oldCanset\u4e0eabsCanset\u7684\u6620\u5c04 \u5f97\u51fa absCanset\u4e0escene\u7684\u6620\u5c04 (\u53c2\u800329076-todo2);\n//        NSDictionary *sceneNewCansetIndexDic = [sceneFo getConIndexDic:newCanset.p];\n//        NSMutableDictionary *sceneAbsCansetIndexDic = [[NSMutableDictionary alloc] init];\n//        for (id sceneIndex in sceneNewCansetIndexDic.allKeys) {\n//            id newCansetIndex = [sceneNewCansetIndexDic objectForKey:sceneIndex];\n//            id absCansetIndex = ARR_INDEX([newIndexDic allKeysForObject:newCansetIndex], 0);\n//            if (absCansetIndex) {\n//                [sceneAbsCansetIndexDic setObject:absCansetIndex forKey:sceneIndex];"
        },
        {
            "comment": "This code is updating the effect strong of a solution fo and comparing index dictionaries from old and new cansets. It also checks if the abstract fo is related, updates the effect strong in the scene fo, and retrieves the new fo strong value based on the proto canset fo for enhancing the abstract fo's eff value by +-1.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":282-297",
            "content": "//            }\n//        }\n//        [absFo updateIndexDic:sceneFo indexDic:sceneAbsCansetIndexDic];\n//        [AITest test27:sceneFo oldCanset:oldCanset.p oldIndexDic:oldIndexDic compareIndexDicFromNewCanset:sceneAbsCansetIndexDic];\n//\n//        //10. oldCanset\u4e0eabsCanset\u65b0\u5173\u8054\u65f6: \u53d6\u51faass\u4e2d\u65e7\u6709\u7684effStrong\u6a21\u578b\u7ee7\u627f\u7ed9absFo (\u53c2\u800329032-todo2.2);\n//        if (!outConAbsIsRelate) {\n//            AIEffectStrong *effStrong = [sceneFo getEffectStrong:sceneFo.count solutionFo:oldCanset.pointer];\n//            [sceneFo updateEffectStrong:effStrong.hStrong solutionFo:absFo.pointer status:ES_HavEff];\n//            [sceneFo updateEffectStrong:effStrong.nStrong solutionFo:absFo.pointer status:ES_NoEff];\n//        }\n//\n//        //11. \u62bd\u8c61fo\u65f6: \u6839\u636eprotoCansetFo\u589e\u5f3aabsFo\u7684Eff\u503c+-1 (\u53c2\u800329032-todo2.3);\n//        //2023.09.01: \u6253\u5f00eff+-1 (\u53c2\u800330124-todo2);\n//        AIEffectStrong *endEffStrong = [sceneFo updateEffectStrong:sceneFo.count solutionFo:absFo.pointer status:es];\n//        NSInteger newFoStrong = [AINetUtils getStrong:absFo atConNode:newCanset type:ATDefault];"
        },
        {
            "comment": "The code sets the old Fo strong value using AINetUtils, logs information about sceneFo and absFo, and returns the updated absFo.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/AIFoundation/AIThinkingControl/TCLearning/AIAnalogy.m\":298-304",
            "content": "//        NSInteger oldFoStrong = [AINetUtils getStrong:absFo atConNode:oldCanset type:ATDefault];\n//        NSLog(@\"sceneFo:F%ld \u6784\u5efaabsCanset:%@ SP:%@ EFF:%@ \u5f3a\u5ea6:new=%ld old=%ld\",sceneFo.pointer.pointerId,Fo2FStr(absFo),CLEANSTR(absFo.spDic),CLEANSTR(endEffStrong),newFoStrong,oldFoStrong);\n//    }\n//    return absFo;\n//}\n@end"
        }
    ]
}