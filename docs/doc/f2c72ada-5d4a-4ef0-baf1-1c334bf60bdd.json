{
    "summary": "AsyncMutableArray is a GCD-based thread-safe class for managing asynchronous mutable arrays, offering addObject, removeObject, and forEach methods for concurrency safety.",
    "details": [
        {
            "comment": "AsyncMutableArray is a class that creates and manages an asynchronous mutable array, using concurrent dispatch queues for safe access. It has methods to get the array, check if it contains an object, and count its elements asynchronously.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Extension/AsyncMutableArray.m\":0-45",
            "content": "//\n//  AsyncMutableArray.m\n//  SMG_NothingIsAll\n//\n//  Created by jia on 2023/7/17.\n//  Copyright \u00a9 2023 XiaoGang. All rights reserved.\n//\n#import \"AsyncMutableArray.h\"\n@interface AsyncMutableArray()\n@property (strong, nonatomic) dispatch_queue_t syncQueue;\n@property (strong, nonatomic) NSMutableArray *arr;\n@end\n@implementation AsyncMutableArray\n-(instancetype)init {\n    self = [super init];\n    if (self) {\n        NSString *identifier = [NSString stringWithFormat:@\"<AsyncMutableArray>%p\",self];\n        self.syncQueue = dispatch_queue_create([identifier UTF8String], DISPATCH_QUEUE_CONCURRENT);\n        self.arr = [NSMutableArray array];\n    }\n    return self;\n}\n- (NSMutableArray *)array {\n    __block NSMutableArray *safeArray;\n    dispatch_sync(_syncQueue, ^{\n        safeArray = self.arr;\n    });\n    return safeArray;\n}\n- (BOOL)containsObject:(id)anObject {\n    __block BOOL isExist = NO;\n    dispatch_sync(_syncQueue, ^{\n        isExist = [self.arr containsObject:anObject];\n    });\n    return isExist;\n}\n- (NSUInteger)count {"
        },
        {
            "comment": "The code provides a synchronized wrapper around an underlying mutable array, ensuring thread safety. It uses GCD (Grand Central Dispatch) to dispatch operations on a private queue, preventing conflicts and race conditions when accessing the array from multiple threads. Each method performs its operation synchronously within this queue, guaranteeing consistent and safe behavior.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Extension/AsyncMutableArray.m\":46-87",
            "content": "    __block NSUInteger count;\n    dispatch_sync(_syncQueue, ^{\n        count = self.arr.count;\n    });\n    return count;\n}\n- (id)objectAtIndex:(NSUInteger)index {\n    __block id obj;\n    dispatch_sync(_syncQueue, ^{\n        if (index < [self.arr count]) {\n            obj = self.arr[index];\n        }\n    });\n    return obj;\n}\n- (NSUInteger)indexOfObject:(id)anObject {\n    __block NSUInteger index = NSNotFound;\n    dispatch_sync(_syncQueue, ^{\n        for (int i = 0; i < [self.arr count]; i ++) {\n            if ([self.arr objectAtIndex:i] == anObject) {\n                index = i;\n                break;\n            }\n        }\n    });\n    return index;\n}\n- (NSEnumerator *)objectEnumerator {\n    __block NSEnumerator *enu;\n    dispatch_sync(_syncQueue, ^{\n        enu = [self.arr objectEnumerator];\n    });\n    return enu;\n}\n- (void)insertObject:(id)anObject atIndex:(NSUInteger)index {\n    dispatch_barrier_async(_syncQueue, ^{\n        if (anObject && index <= [self.arr count]) {\n            [self.arr insertObject:anObject atIndex:index];"
        },
        {
            "comment": "This code defines an asynchronous mutable array with thread-safe operations. It uses a GCD dispatch queue to synchronize access to the array, ensuring that each operation is performed atomically. The methods include addObject, addObjectsFromArray, replaceObjectAtIndex, removeObjectAtIndex, removeObject, and removeLastObject, all of which are wrapped in a dispatch_barrier_async block for concurrency safety.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Extension/AsyncMutableArray.m\":88-132",
            "content": "        }\n    });\n}\n- (void)addObject:(id)anObject {\n    dispatch_barrier_async(_syncQueue, ^{\n        if(anObject){\n            [self.arr addObject:anObject];\n        }\n    });\n}\n- (void)addObjectsFromArray:(NSArray*)objs {\n    dispatch_barrier_async(_syncQueue, ^{\n        if(ARRISOK(objs)){\n            [self.arr addObjectsFromArray:objs];\n        }\n    });\n}\n- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject {\n    dispatch_barrier_async(_syncQueue, ^{\n        if (anObject && index < [self.arr count]) {\n            [self.arr replaceObjectAtIndex:index withObject:anObject];\n        }\n    });\n}\n- (void)removeObjectAtIndex:(NSUInteger)index {\n    dispatch_barrier_async(_syncQueue, ^{\n        if (index < [self.arr count]) {\n            [self.arr removeObjectAtIndex:index];\n        }\n    });\n}\n- (void)removeObject:(id)anObject {\n    dispatch_barrier_async(_syncQueue, ^{\n        [self.arr removeObject:anObject];\n    });\n}\n- (void)removeLastObject {\n    dispatch_barrier_async(_syncQueue, ^{\n        [self.arr removeLastObject];"
        },
        {
            "comment": "AsyncMutableArray class provides synchronized access to an underlying NSMutableArray instance. Methods like removeObjectsInRange, removeAllObjects and forEach are wrapped with GCD dispatch_barrier_async to ensure thread safety when accessing the array from multiple threads. The dealloc method releases the _syncQueue if it exists.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/SMG_NothingIsAll/Extension/AsyncMutableArray.m\":133-162",
            "content": "    });\n}\n- (void)removeObjectsInRange:(NSRange)range {\n    dispatch_barrier_async(_syncQueue, ^{\n        [self.arr removeObjectsInRange:range];\n    });\n}\n- (void) removeAllObjects {\n    dispatch_barrier_async(_syncQueue, ^{\n        [self.arr removeAllObjects];\n    });\n}\n- (void) forEach:(void(^)(id))itemBlock {\n    dispatch_barrier_async(_syncQueue, ^{\n        for (id item in self.arr) {\n            itemBlock(item);\n        }\n    });\n}\n- (void)dealloc {\n    if (_syncQueue) {\n        _syncQueue = NULL;\n    }\n}\n@end"
        }
    ]
}