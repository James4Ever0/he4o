{
    "summary": "The code defines a class with methods for creating/retrieving groups, comparing and merging nodes using compatibility algorithms. It is part of the SMGNetVision framework that includes functions for dataset comparison, model conversion, and finding minimum/maximum values recursively. The methods find models based on data size and comparison with other models.",
    "details": [
        {
            "comment": "This code defines an NVModuleUtil class with two methods. The first method, `getOrCreateGroupWithData:groups:` takes in data and an array of groups, checks if the data is valid and already exists within any of the existing groups, and if not, creates a new group containing the data. The second method, `isRelateWithData1:data2:compareModels:` takes in two pieces of data and an array of compare models to check if they are related according to the compare models.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/SMGNetVision/Core/Util/NVModuleUtil.m\":0-42",
            "content": "//\n//  NVModuleUtil.m\n//  SMG_NothingIsAll\n//\n//  Created by jia on 2019/7/10.\n//  Copyright \u00a9 2019\u5e74 XiaoGang. All rights reserved.\n//\n#import \"NVModuleUtil.h\"\n#import \"NodeCompareModel.h\"\n@implementation NVModuleUtil\n+(NSArray*) getOrCreateGroupWithData:(id)data groups:(NSMutableArray*)groups{\n    //1. \u65e0\u6548\u5219\u8fd4nil;\n    if (!data) {\n        return nil;\n    }\n    //2. \u627e\u5df2\u6709,\u5219\u53d6\u51fa;\n    if (ISOK(groups, NSMutableArray.class)) {\n        for (NSArray *oldGroup in groups) {\n            if ([oldGroup containsObject:data]) {\n                return oldGroup;\n            }\n        }\n    }\n    //3. \u6ca1\u627e\u5230,\u5219\u65b0\u5efa\n    NSArray *newGroup = @[data];\n    [groups addObject:newGroup];\n    return newGroup;\n}\n+(BOOL) isRelateWithData1:(id)data1 data2:(id)data2 compareModels:(NSArray*)compareModels{\n    //1. \u6570\u636e\u68c0\u67e5\n    compareModels = ARRTOOK(compareModels);\n    if (data1 && data2) {\n        //2. \u68c0\u67e5data1\u548cdata2\u662f\u5426\u6709\u5173\u7cfb\n        for (NodeCompareModel *model in compareModels) {\n            if ([model isA:data1 andB:data2]) {\n                return true;\n            }"
        },
        {
            "comment": "This method compares two nodes, n1 and n2, based on their corresponding indexes in a dictionary. It first converts the objects to data and retrieves their respective indexes. If the indexes are equal, it returns NSOrderedSame; otherwise, it determines whether n1 is less than or greater than n2 and returns the appropriate comparison result (NSOrderedAscending or NSOrderedDescending). If either n1 or n2 is nil, it returns NSOrderedSame.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/SMGNetVision/Core/Util/NVModuleUtil.m\":43-75",
            "content": "        }\n    }\n    return false;\n}\n/**\n *  MARK:--------------------\u5bf9\u6bd4n1\u548cn2\u7684\u5927\u5c0f--------------------\n *  \u8bf4\u660e:\n *      1. \u5728compareModels\u4e2d,\u6570\u636e\u662f\u4e00\u5bf9\u4e00\u7684\u5143\u7d20,\u5982:[a>b,b>c,c>d,d>e];\n *      2. \u6211\u4eec\u8981\u7684\u7ed3\u679c\u53ef\u80fd\u662f\u5bf9\u6bd4a\u4e0ee;\n *      3. \u6211\u4eec\u5148\u627e\u51fa\u542ba\u7684\u5143\u7d20,\u5f97\u51fab;\n *      4. \u518d\u627e\u51fa\u542bb\u7684\u5143\u7d20\u5f97\u51fac,\u4ee5\u6b64\u7c7b\u63a8,\u76f4\u5230\u627e\u51fae;\n *      \u603b\u7ed3:\u5148\u627e\u51fa\u5305\u542ba\u7684\u5143\u7d20,\u5e76\u5c0f\u7684\u5411\u5c0f\u627e,\u5927\u7684\u5411\u5927\u627e,\u76f4\u5230\u627e\u51fa\u7ed3\u679c;\n *\n *  \u5f02\u5e38:\n *      1. \u6b7b\u4ea1\u73af:(\u5373a>b & b>a\u7684\u60c5\u51b5),\u5bfc\u81f4\u7684\u4e92\u76f8\u5f15\u7528;\n *      2. \u89e3\u51b3:\u4e07\u4e00\u6709\u6b7b\u4ea1\u73af,\u4ec5\u4f1a\u5bfc\u81f4\u6392\u7248\u9519\u8bef;\n *\n *  BUG\u8bb0\u5f55:\n *      1. \u56e0n1,n2\u5e76\u975e\u76f4\u63a5\u5927\u5c0f,\u800c\u662f\u95f4\u9694\u4e86\u5f88\u591a\u4e2amodel,\u5bfc\u81f4\u7684\u8fd4\u56desame\u6392\u7248\u9519\u8bef;\n *      2. \u590d\u73b0\u63d0\u793a,\u5148\u76f4\u62953\u4e2a,\u7136\u540e\u8bb0\u4e0b\u6700\u5927\u7684conAlgNode,\u5355\u72ec\u8ffd\u52a0\u8fdb\u6765,\u7136\u540e\u8ffd\u52a0\u5176absPorts,\u76f4\u81f3\u5168\u7eb5\u5411\u52a0\u8f7d\u8fdb\u6765;\n *\n */\n+(NSComparisonResult)compareNodeData1:(id)n1 nodeData2:(id)n2 indexDic:(NSDictionary*)indexDic{\n    indexDic = DICTOOK(indexDic);\n    if (n1 && n2) {\n        NSData *key1 = OBJ2DATA(n1);\n        NSData *key2 = OBJ2DATA(n2);\n        int index1 = [NUMTOOK([indexDic objectForKey:key1]) intValue];\n        int index2 = [NUMTOOK([indexDic objectForKey:key2]) intValue];\n        return (index1 == index2) ? NSOrderedSame : ((index1 < index2) ? NSOrderedAscending : NSOrderedDescending);\n    }\n    return NSOrderedSame;"
        },
        {
            "comment": "The code checks data integrity, then uses a compatibility algorithm to group nodes (one-to-one comparison and merging). If two nodes are related according to the compareModels, it removes the previous groups and adds the merged one.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/SMGNetVision/Core/Util/NVModuleUtil.m\":76-100",
            "content": "}\n+(NSMutableArray*) getSortGroups:(NSArray*)nodeArr compareModels:(NSArray*)compareModels indexDic:(NSDictionary*)indexDic{\n    //1. \u6570\u636e\u68c0\u67e5\n    indexDic = DICTOOK(indexDic);\n    compareModels = ARRTOOK(compareModels);\n    nodeArr = ARRTOOK(nodeArr);\n    NSMutableArray *groups = [[NSMutableArray alloc] init];\n    //2. \u7528\u76f8\u5bb9\u7b97\u6cd5,\u5206\u7ec4 (\u4e00\u4e00\u5bf9\u6bd4,\u5e76\u5408\u5e76);\n    for (NSInteger i = 0; i < nodeArr.count; i++) {\n        id iData = ARR_INDEX(nodeArr, i);\n        NSArray *iGroup = [NVModuleUtil getOrCreateGroupWithData:iData groups:groups];\n        for (NSInteger j = i + 1; j < nodeArr.count; j++) {\n            id jData = ARR_INDEX(nodeArr, j);\n            NSArray *jGroup = [NVModuleUtil getOrCreateGroupWithData:jData groups:groups];\n            ///1. \u5f53iData\u548cjData\u6709\u5173\u7cfb\u65f6;\n            if (![iGroup isEqual:jGroup] && [NVModuleUtil isRelateWithData1:iData data2:jData compareModels:compareModels]) {\n                ///2. \u6709\u5173\u7cfb,\u5219\u79fb\u9664\u5408\u5e76\u524d\u7684group;\n                [groups removeObject:iGroup];\n                [groups removeObject:jGroup];\n                ///3. \u5e76\u5c06iGroup\u548cjGroup\u5408\u5e76,\u52a0\u5230groups;"
        },
        {
            "comment": "Code processes groups of data, merges them, reorders and sorts the merged groups. It checks if a specific data is related to any group and returns the sorted groups.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/SMGNetVision/Core/Util/NVModuleUtil.m\":101-127",
            "content": "                NSMutableArray *mergeGroup = [[NSMutableArray alloc] init];\n                [mergeGroup addObjectsFromArray:iGroup];\n                [mergeGroup addObjectsFromArray:jGroup];\n                [groups addObject:mergeGroup];\n                ///4. \u9700\u8981\u91cd\u65b0\u83b7\u53d6\u65b0\u7684iGroup;\n                iGroup = [NVModuleUtil getOrCreateGroupWithData:iData groups:groups];\n            }\n        }\n    }\n    //3. \u5bf9groups\u4e2d,\u6bcf\u4e00\u7ec4\u8fdb\u884c\u72ec\u7acb\u6392\u5e8f,\u5e76\u53d6\u7f16\u53f7\u7ed3\u679c; (\u6392\u5e8f:\u4ece\u5177\u8c61\u5230\u62bd\u8c61)\n    NSMutableArray *sortGroups = [[NSMutableArray alloc] init];\n    for (NSArray *group in groups) {\n        NSArray *sortGroup = [group sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) {\n            return [NVModuleUtil compareNodeData1:obj1 nodeData2:obj2 indexDic:indexDic];\n        }];\n        [sortGroups addObject:sortGroup];\n    }\n    return sortGroups;\n}\n+(BOOL) containsRelateWithData:(id)checkData fromGroup:(NSArray*)group compareModels:(NSArray*)compareModels{\n    //1. \u6570\u636e\u68c0\u67e5\n    group = ARRTOOK(group);\n    //2. \u68c0\u67e5group\u4e2d,\u662f\u5426\u6709\u5143\u7d20\u4e0echeckData\u6709\u5173\u7cfb;"
        },
        {
            "comment": "This code appears to be part of a larger system, specifically the SMGNetVision framework. The function in question, `isRelateWithData1:data2:compareModels:`, checks if there is any relation between two data sets within a group using specified compare models. If a relation is found, it returns true; otherwise, false. The code also contains another function, `convertIndexDicWithCompareModels:`, which seems to prepare and process data in order to convert 'compareModels' into an index dictionary (possibly for further use).",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/SMGNetVision/Core/Util/NVModuleUtil.m\":128-157",
            "content": "    if (checkData) {\n        for (id groupData in group) {\n            if ([NVModuleUtil isRelateWithData1:checkData data2:groupData compareModels:compareModels]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n *  MARK:--------------------compareModels\u8f6c\u4e3aindexDic--------------------\n *  @result nutnull\n */\n+(NSDictionary*)convertIndexDicWithCompareModels:(NSArray*)compareModels{\n    //1. \u6570\u636e\u51c6\u5907\n    compareModels = ARRTOOK(compareModels);\n    NSMutableDictionary *result = [[NSMutableDictionary alloc] init];\n    //2. \u627e\u51fa\u6700\u5177\u8c61\n    for (NodeCompareModel *model in compareModels) {\n        //3. \u5047\u8bbe\u5f53\u524d\u4e3a\u6700\u5c0f\n        NSArray *smallers = @[model.smallNodeData];\n        do {\n            NSMutableArray *newSmallers = [[NSMutableArray alloc] init];\n            for (id smaller in smallers) {\n                //4. \u5c1d\u8bd5\u627e\u6bd4\u5047\u8bbe\u7684\u6700\u5c0f\u66f4\u5c0f;\n                NSArray *models = [self findModelsWithBigData:smaller compareModels:compareModels];\n                if (!ARRISOK(models)) {\n                    //5. \u627e\u4e0d\u5230\u66f4\u5c0f,smaller\u5df2\u7ecf\u662f\u6700\u5c0f\u4e86;"
        },
        {
            "comment": "This code implements a comparison algorithm to find the minimum index in an array. It iteratively compares the current smallest with other nodes, assumes the smallest node is updated as the new smallest, and recurs until all possible smaller nodes are considered. Finally, it lists the other indices while keeping the minimum index intact.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/SMGNetVision/Core/Util/NVModuleUtil.m\":158-185",
            "content": "                    [result setObject:@(0) forKey:OBJ2DATA(smaller)];\n                }else{\n                    //6. \u6709\u66f4\u5c0f,\u5219\u6536\u96c6\u5e76\u518d\u5047\u8bbe\u4e3a\u6700\u5c0f,\u7ee7\u7eed\u9012\u5f52\u67e5\u66f4\u5c0f;\n                    for (NodeCompareModel *model in models) {\n                        [newSmallers addObject:model.smallNodeData];\n                    }\n                }\n            }\n            //7. \u4f7f\u7528\u65b0\u7684smallers\u5047\u8bbe,\u5e76\u9012\u5f52\u627e\u66f4\u5c0f;\n            smallers = newSmallers;\n        } while (ARRISOK(smallers));\n    }\n    //8. \u5217\u5176\u5b83index;\n    for (NSData *key in result.allKeys) {\n        id smaller = DATA2OBJ(key);\n        //3. \u5047\u8bbe\u5f53\u524d\u4e3a\u6700\u5c0f\n        NSArray *smallers = @[smaller];\n        do {\n            NSMutableArray *newSmallers = [[NSMutableArray alloc] init];\n            for (id smaller in smallers) {\n                //4. \u5c1d\u8bd5\u627e\u6bd4\u5047\u8bbe\u7684\u6700\u5c0f\u66f4\u5927;\n                NSArray *models = [self findModelsWithSmallData:smaller compareModels:compareModels];\n                if (ARRISOK(models)) {\n                    //6. \u6709\u66f4\u5927,\u5219index+1;\n                    for (NodeCompareModel *model in models) {\n                        int smallIndex = [NUMTOOK([result objectForKey:OBJ2DATA(smaller)]) intValue];"
        },
        {
            "comment": "This code snippet seems to be implementing a method that finds the maximum value among small and big data items, and then recursively searches for smaller or larger values depending on the given condition. It utilizes methods like NUMTOOK, OBJ2DATA, ARRISOK, result object manipulation, and array operations. The code also includes private methods for finding related models with big data and compare models.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/SMGNetVision/Core/Util/NVModuleUtil.m\":186-213",
            "content": "                        int bigIndex = smallIndex + 1;\n                        //7. \u5b58\u5230result\u4e2d;\n                        int oldIndex = [NUMTOOK([result objectForKey:OBJ2DATA(model.bigNodeData)]) intValue];\n                        int newIndex = MAX(oldIndex, bigIndex);\n                        [result setObject:@(newIndex) forKey:OBJ2DATA(model.bigNodeData)];\n                        //8. \u6536\u96c6\u65b0\u7684smallers\u5e76\u9012\u5f52\u627e\u66f4\u5927;\n                        [newSmallers addObject:model.bigNodeData];\n                    }\n                }\n            }\n            //7. \u4f7f\u7528\u65b0\u7684smallers\u5047\u8bbe,\u5e76\u9012\u5f52\u627e\u66f4\u5c0f;\n            smallers = newSmallers;\n        } while (ARRISOK(smallers));\n    }\n    return result;\n}\n//MARK:===============================================================\n//MARK:                     < PrivateMethod >\n//MARK:===============================================================\n/**\n *  MARK:--------------------\u627e\u51fa \"\u62bd\u8c61/\u5177\u8c61\" \u65b9\u5411,\u6709\u5173\u7cfb\u7684models--------------------\n */\n+(NSArray*) findModelsWithBigData:(id)bigData compareModels:(NSArray*)compareModels{"
        },
        {
            "comment": "This code defines three methods to find models based on data size and comparison with other models. It takes a data parameter, a boolean indicating if the data is big or small, and an array of compareModels. The methods return an array of models that match the given criteria. If data and compareModels are valid, it iterates through each model in compareModels and adds the matching ones to the result array.",
            "location": "\"/media/root/Prima/works/he4o/docs/src/ThirdParty/SMGNetVision/Core/Util/NVModuleUtil.m\":214-231",
            "content": "    return [self findModelsWithData:bigData dataIsBig:true compareModels:compareModels];\n}\n+(NSArray*) findModelsWithSmallData:(id)smallData compareModels:(NSArray*)compareModels{\n    return [self findModelsWithData:smallData dataIsBig:false compareModels:compareModels];\n}\n+(NSArray*) findModelsWithData:(id)data dataIsBig:(BOOL)dataIsBig compareModels:(NSArray*)compareModels{\n    NSMutableArray *result = [[NSMutableArray alloc] init];\n    if (data && ARRISOK(compareModels)) {\n        for (NodeCompareModel *model in compareModels) {\n            if ([data isEqual:(dataIsBig ? model.bigNodeData : model.smallNodeData)]) {\n                [result addObject:model];\n            }\n        }\n    }\n    return result;\n}\n@end"
        }
    ]
}